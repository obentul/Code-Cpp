在SDK中输出API函数的时候，经常会利用WINAPI对函数进行约定，WINAPI在WIN32中，
它被定义为__stdcall

函数调用约定有多种，这里简单说一下：

1、__stdcall调用约定相当于16位动态库中经常使用的PASCAL调用约定。在32位的
VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal
外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实
质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参
数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说
明）。

_stdcall是Pascal程序的缺省调用方式，通常用于Win32 Api中，函数采用从右到左的
压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，
在函数名后加上"@"和参数的字节数。

2、C调用约定（即用__cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把
参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数
的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。

_cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，
所以产生的可执行文件大小会比调用_stdcall函数的大。函数采用从右到左的压栈方
式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。

3、__fastcall调用约定是“人”如其名，它的主要特点就是快，因为它是通过寄存器
来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下
的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函
数名修饰约定方面，它和前两者均不同。

_fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上"@"前
缀，在函数名后加上"@"和参数的字节数。

4、thiscall仅仅应用于“C++”成员函数。this指针存放于CX寄存器，参数从右到左
压。thiscall不是关键词，因此不能被程序员指定。

5、naked call采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来
保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。
naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec共同
使用。

关键字 __stdcall、__cdecl和__fastcall可以直接加在要输出的函数前，也可以在编
译环境的Setting...\C/C++ \Code Generation项选择。当加在输出函数前的关键字与
编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数
分别为/Gz、/Gd和/Gr。缺省状态为/Gd，即__cdecl。
