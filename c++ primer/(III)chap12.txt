


#1 ==============================================================================================================

拷贝构造，拷贝赋值运算符，移动构造，移动赋值运算符，析构。

上面五个特殊的函数统称”拷贝控制操作“，如果自己没有定义，那么编译器会自动为我们创建。

#2 ==============================================================================================================

拷贝构造函数的原型：
class A{
public:
    A(const A&);		//const 类名 的引用
}

拷贝构造的原型必须是 const类名的引用，而且一定不能是explicit的，因为拷贝构造在很多时候是被隐式调用的。



如果没有自定义拷贝构造函数，那么编译器会自动生成。
和默认合成构造函数不同，即便我们定义了其他构造函数，也不能阻止编译器为我们生成拷贝构造函数，所以唯一覆盖
合成拷贝构造函数的方法就是自定义并重写。


#3 ==============================================================================================================

大部分情况下，编译器生成的拷贝构造函数会将  非static成员变量挨个赋值给新的对象。

如果成员变量中也有类，那么会继续调用这个类的拷贝构造，依次递归下去。内置类型则直接赋值

	注：c++和c一样，不能对数组进行批量赋值，但是在编译器和成的拷贝构造函数中，如果成员变量有数组，
	    那么在创建新对象的时候，也会进行数组的赋值

#4 ==============================================================================================================

为什么拷贝构造函数的参数必须是引用？？？

如果不是引用，当使用类实例来初始化另外一个类时，会调用拷贝构造函数，此时拷贝构造发现传进来的是值，不是引用，那么
它便会去要求一个拷贝动作，而自己就是拷贝构造，这就相当于自己调自己，永远也没法进入正常的流程。和 ”先有鸡还是先有蛋
“的问题是一样的。

#5 ==============================================================================================================




#6 ==============================================================================================================
