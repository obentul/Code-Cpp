
拷贝构造 即 复制构造 ，如果把类当做内置类型来看，哪些需要初始化的地方都是赋值/拷贝动作




#1 ==============================================================================================================

拷贝构造，拷贝赋值运算符，移动构造，移动赋值运算符，析构。

上面五个特殊的函数统称”拷贝控制操作“，如果自己没有定义，那么编译器会自动为我们创建。

#2 ==============================================================================================================

拷贝构造函数的原型：
class A{
public:
    A(const A&);		//const 类名 的引用
}

拷贝构造的原型必须是 const类名的引用，而且一定不能是explicit的，因为拷贝构造在很多时候是被隐式调用的。



如果没有自定义拷贝构造函数，那么编译器会自动生成。
和默认合成构造函数不同，即便我们定义了其他构造函数，也不能阻止编译器为我们生成拷贝构造函数，所以唯一覆盖
合成拷贝构造函数的方法就是自定义并重写。


#3 ==============================================================================================================

大部分情况下，编译器生成的拷贝构造函数会将  非static成员变量挨个赋值给新的对象。

如果成员变量中也有类，那么会继续调用这个类的拷贝构造，依次递归下去。内置类型则直接赋值

	注：c++和c一样，不能对数组进行批量赋值，但是在编译器和成的拷贝构造函数中，如果成员变量有数组，
	    那么在创建新对象的时候，也会进行数组的赋值

#4 ==============================================================================================================

为什么拷贝构造函数的参数必须是引用？？？

如果不是引用，当使用类实例来初始化另外一个类时，会调用拷贝构造函数，此时拷贝构造发现传进来的是值，不是引用，那么
它便会去要求一个拷贝动作，而自己就是拷贝构造，这就相当于自己调自己，永远也没法进入正常的流程。和 ”先有鸡还是先有蛋
“的问题是一样的。

#5 ==============================================================================================================

如果函数原型如下：

A func(A);

那么在调用func的时候，传参会进行一次拷贝初始化(使用入参构造实参)，在调用返回赋值时也会进行一次拷贝初始化或赋值初始化
，这取决于函数被怎么使用。比如  A a = func(a_1);	//这里a调用了赋值初始化
				A a(func(a_1));		//这里a调用了拷贝初始化

--------------------

如果函数原型参数为引用：

A& func(A& a);

那么不会触发拷贝构造初始化和赋值初始化，因为用的还是原来的那个对象。



		小结： 其实很好理解，就是看传值还是传引用，传值就需要初始化，传引用就不需要


#6 ==============================================================================================================

（！）强调：在类定义中一定不要出现下面语句：
		A(A);

      原因；这句话在编译阶段就无法通过，因为它试图自定义拷贝构造函数，但是它会造成拷贝构造失败，见#4。编译器

	    在 重载方面 ，无法区分 实例 和 引用，即 参数  A 和 A& 并不会触发重载

#7 ==============================================================================================================

如果类未重载赋值运算符，那么编译器会自动生成赋值运算符的动作。

#8
#==============================================================================================================

重载运算符的本质是函数。
某些重载运算符必须定义为成员函数。


如果运算符是成员函数，那么这个运算符的左侧对象就默认绑定到this上，这是什么意思？看下面这个例子：

class A{

   operator+(A a);	

}

void A::operator+(A a)
{
   ...
}

A a;
A b;
a+b;	//等于 a.+(b);		即调用a的 operator+ 成员函数，接收b作为入参


     小结：总结起来就是，运算符的左侧是调用实例，右侧是入参实例

#9
#==============================================================================================================

赋值运算符： operator=

赋值运算符的重载版本通常的原型为：   A& operator=(const A&);  即接收一个引用，返回一个指向调用实例的引用。


	注：其实按照使用习惯，赋值动作很多时候不需要返回值，仅仅完成把 = 右侧的值赋给左侧即可。但是

	    赋值动作是一个表达式，表达式要有返回值，这是内置类型赋值动作的惯例。因此，为了在行为上与内置

	    类型保持一致，自定义类的赋值运算符也要求有返回值，而这个返回值便是调用者自己的引用。

	    所以实现的模板为：

			A& A::operator=(const A& a){
				...			//成员变量挨个赋值 ，以及其他的一些想要附加的动作
				return *this;		//（！）把指向自己的指针this的值返回，即就是自己的引用
			}

	（！）在赋值运算符中，切记不可对static成员变量进行赋值，即上面的 ... 中不能对static成员做赋值，一是
	      没意义，二是可能编译不通过，三是即便通过运行起来可能会有问题

#10
#==============================================================================================================

构造函数：构造函数初始化非static成员变量，然后再做一些其他自定义动作
析构函数：析构函数销毁所有非static成员变量(自定义类类型的成员变量，内置类型会自动释放)，其实就是调用成员变量
	  的析构(如果有析构的话，内置类型就自动释放)，然后做一些自定义动作


简言之：构造会对成员变量挨个构造，析构则挨个析构。而自定的动作，一般就是 动态内存分配 和 释放。
	比如，如果构造时new了内存，析构的时候就要delete，不然就是内存泄露


	（！）成员变量对于类实例来说，就是局部变量，当类实例销毁了，局部变量也要被销毁。
	      离开了作用域的局部变量自然而然要销毁。

	（！）因此，可以把类实例看做是一个局部作用域，毕竟从语法上看，类也是用大括号括起来的，可能在编译器
	      处理时确实是和局部作用域使用的同样处理方式，或者是为了统一，模拟了相同的行为

#（！）11
#==============================================================================================================

new 分两步：		分配内存 和 调用构造函数
构造函数又分两步：	初始化成员(有初始化列表则用，没有则使用默认初始化列表)  和  执行构造函数的函数体

			注：默认初始化的顺序按照成员定义的先后，如果自定义列表，则按照列表顺序


delete 分两步：		调用析构函数 和 释放内存
析构函数又分两步：	执行构造函数体  和  销毁成员

			注：销毁成员的顺序是按照成员定义的逆序



	小结：可见构造和析构的顺序都是反向的。

#（！）12
#==============================================================================================================

	在#11中提到了析构的销毁成员变量，如果类中保存了一个指针成员变量，那么析构时只会析构这个指针，而不会

	析构指针指向的内容。因此，在使用指针时，务必注意是否指向了new出来的内存，如果是，这部分内存有没有什么

	地方会释放它，如果没有，那么请在析构函数中手动释放。


（！）这也很好理解，析构是销毁局部变量(成员变量)，而不是delete成员变量，如果是delete指针，则会释放指针指向的内容。


#13
#==============================================================================================================

参照#12描述，这个时候智能共享指针 shared_ptr 的优势就体现出来了，shared_ptr是类，有自己的析构函数，而普通指针

是内置类型(指向类的指针也是内置类型)，不具备析构函数。shared_ptr 析构的内部实现就有对引用计数的判断和被指向实例

的 “计数为0时释放“ 这么一个默认动作。因此如果类中都使用智能指针，那么可以不用在析构函数中手动释放被指向的内容。

因为 shared_ptr 的析构函数会完成这么一个动作。


#14
#==============================================================================================================

如果一个类需要自定义析构函数，那么根据经验判断，这个类肯定需要  自定义拷贝构造 和 拷贝赋值。


比如：某个类有指针类型的数据成员，指向new出来的内存。那么这个类必须要在析构函数中delete这个指针。
      那么，如果使用默认拷贝构造会怎么样，此时这个指针会被复制，此时就有多个指针指向相同的动态内存区，当其中
      一个实例在析构中释放动态内存区是，其他实例的指针将变为野指针。因此，需要自定义拷贝构造和拷贝赋值，在
      其中，将指针赋值换成创建新对象，然后再赋值给指针。   

	" 即，每个实例都有一个指针和一个被指的动态内存区域，而不是所有实例通过指针赋值的方式共享一个动态内存"

	
    （！）三/五法则：拷贝构造，拷贝赋值，析构，这三个只要有一个是自定义的，其他两个也务必自定义，因为按照经验，
	  肯定会有风险存在。当然，这里的自定义是指需要仔细筛查风险点，而不是无脑地自定义一个空函数。


#15 ==============================================================================================================

=default 补充

只能对具有合成版本的函数使用 =default ，=default是要求编译器为我们生成默认版本的函数(包括普通函数 和 构造函数)，
如果这个函数都没有合成版本(由编译器生成)，那么=default告诉编译器，编译器才不鸟你，直接报错。


#16
#=============================================================================================================

阻止拷贝
































