
拷贝构造 即 复制构造 ，如果把类当做内置类型来看，哪些需要初始化的地方都是赋值/拷贝动作




#1 ==============================================================================================================

拷贝构造，拷贝赋值运算符，移动构造，移动赋值运算符，析构。

上面五个特殊的函数统称”拷贝控制操作“，如果自己没有定义，那么编译器会自动为我们创建。

#2 ==============================================================================================================

拷贝构造函数的原型：
class A{
public:
    A(const A&);		//const 类名 的引用
}

拷贝构造的原型必须是 const类名的引用，而且一定不能是explicit的，因为拷贝构造在很多时候是被隐式调用的。



如果没有自定义拷贝构造函数，那么编译器会自动生成。
和默认合成构造函数不同，即便我们定义了其他构造函数，也不能阻止编译器为我们生成拷贝构造函数，所以唯一覆盖
合成拷贝构造函数的方法就是自定义并重写。


#3 ==============================================================================================================

大部分情况下，编译器生成的拷贝构造函数会将  非static成员变量挨个赋值给新的对象。

如果成员变量中也有类，那么会继续调用这个类的拷贝构造，依次递归下去。内置类型则直接赋值

	注：c++和c一样，不能对数组进行批量赋值，但是在编译器和成的拷贝构造函数中，如果成员变量有数组，
	    那么在创建新对象的时候，也会进行数组的赋值

#4 ==============================================================================================================

为什么拷贝构造函数的参数必须是引用？？？

如果不是引用，当使用类实例来初始化另外一个类时，会调用拷贝构造函数，此时拷贝构造发现传进来的是值，不是引用，那么
它便会去要求一个拷贝动作，而自己就是拷贝构造，这就相当于自己调自己，永远也没法进入正常的流程。和 ”先有鸡还是先有蛋
“的问题是一样的。

#5 ==============================================================================================================

如果函数原型如下：

A func(A);

那么在调用func的时候，传参会进行一次拷贝初始化(使用入参构造实参)，在调用返回赋值时也会进行一次拷贝初始化或赋值初始化
，这取决于函数被怎么使用。比如  A a = func(a_1);	//这里a调用了赋值初始化
				A a(func(a_1));		//这里a调用了拷贝初始化

--------------------

如果函数原型参数为引用：

A& func(A& a);

那么不会触发拷贝构造初始化和赋值初始化，因为用的还是原来的那个对象。



		小结： 其实很好理解，就是看传值还是传引用，传值就需要初始化，传引用就不需要


#6 ==============================================================================================================

（！）强调：在类定义中一定不要出现下面语句：
		A(A);

      原因；这句话在编译阶段就无法通过，因为它试图自定义拷贝构造函数，但是它会造成拷贝构造失败，见#4。编译器

	    在 重载方面 ，无法区分 实例 和 引用，即 参数  A 和 A& 并不会触发重载

#7 ==============================================================================================================

如果类未重载赋值运算符，那么编译器会自动生成赋值运算符的动作。

#8
#==============================================================================================================

重载运算符的本质是函数。
某些重载运算符必须定义为成员函数。


如果运算符是成员函数，那么这个运算符的左侧对象就默认绑定到this上，这是什么意思？看下面这个例子：

class A{

   operator+(A a);	

}

void A::operator+(A a)
{
   ...
}

A a;
A b;
a+b;	//等于 a.+(b);		即调用a的 operator+ 成员函数，接收b作为入参


     小结：总结起来就是，运算符的左侧是调用实例，右侧是入参实例

#9
#==============================================================================================================

赋值运算符： operator=

赋值运算符的重载版本通常的原型为：   A& operator=(const A&);  即接收一个引用，返回一个指向调用实例的引用。


	注：其实按照使用习惯，赋值动作很多时候不需要返回值，仅仅完成把 = 右侧的值赋给左侧即可。但是

	    赋值动作是一个表达式，表达式要有返回值，这是内置类型赋值动作的惯例。因此，为了在行为上与内置

	    类型保持一致，自定义类的赋值运算符也要求有返回值，而这个返回值便是调用者自己的引用。

	    所以实现的模板为：

			A& A::operator=(const A& a){
				...			//成员变量挨个赋值 ，以及其他的一些想要附加的动作
				return *this;		//（！）把指向自己的指针this的值返回，即就是自己的引用
			}

	（！）在赋值运算符中，切记不可对static成员变量进行赋值，即上面的 ... 中不能对static成员做赋值，一是
	      没意义，二是可能编译不通过，三是即便通过运行起来可能会有问题

#10
#==============================================================================================================

构造函数：构造函数初始化非static成员变量，然后再做一些其他自定义动作
析构函数：析构函数销毁所有非static成员变量(自定义类类型的成员变量，内置类型会自动释放)，其实就是调用成员变量
	  的析构(如果有析构的话，内置类型就自动释放)，然后做一些自定义动作


简言之：构造会对成员变量挨个构造，析构则挨个析构。而自定的动作，一般就是 动态内存分配 和 释放。
	比如，如果构造时new了内存，析构的时候就要delete，不然就是内存泄露


	（！）成员变量对于类实例来说，就是局部变量，当类实例销毁了，局部变量也要被销毁。
	      离开了作用域的局部变量自然而然要销毁。

	（！）因此，可以把类实例看做是一个局部作用域，毕竟从语法上看，类也是用大括号括起来的，可能在编译器
	      处理时确实是和局部作用域使用的同样处理方式，或者是为了统一，模拟了相同的行为

#（！）11
#==============================================================================================================

new 分两步：		分配内存 和 调用构造函数
构造函数又分两步：	初始化成员(有初始化列表则用，没有则使用默认初始化列表)  和  执行构造函数的函数体

			注：默认初始化的顺序按照成员定义的先后，如果自定义列表，则按照列表顺序


delete 分两步：		调用析构函数 和 释放内存
析构函数又分两步：	执行构造函数体  和  销毁成员

			注：销毁成员的顺序是按照成员定义的逆序



	小结：可见构造和析构的顺序都是反向的。

#（！）12
#==============================================================================================================

	在#11中提到了析构的销毁成员变量，如果类中保存了一个指针成员变量，那么析构时只会析构这个指针，而不会

	析构指针指向的内容。因此，在使用指针时，务必注意是否指向了new出来的内存，如果是，这部分内存有没有什么

	地方会释放它，如果没有，那么请在析构函数中手动释放。


（！）这也很好理解，析构是销毁局部变量(成员变量)，而不是delete成员变量，如果是delete指针，则会释放指针指向的内容。


#13
#==============================================================================================================

参照#12描述，这个时候智能共享指针 shared_ptr 的优势就体现出来了，shared_ptr是类，有自己的析构函数，而普通指针

是内置类型(指向类的指针也是内置类型)，不具备析构函数。shared_ptr 析构的内部实现就有对引用计数的判断和被指向实例

的 “计数为0时释放“ 这么一个默认动作。因此如果类中都使用智能指针，那么可以不用在析构函数中手动释放被指向的内容。

因为 shared_ptr 的析构函数会完成这么一个动作。


#14
#==============================================================================================================

如果一个类需要自定义析构函数，那么根据经验判断，这个类肯定需要  自定义拷贝构造 和 拷贝赋值。


比如：某个类有指针类型的数据成员，指向new出来的内存。那么这个类必须要在析构函数中delete这个指针。
      那么，如果使用默认拷贝构造会怎么样，此时这个指针会被复制，此时就有多个指针指向相同的动态内存区，当其中
      一个实例在析构中释放动态内存区是，其他实例的指针将变为野指针。因此，需要自定义拷贝构造和拷贝赋值，在
      其中，将指针赋值换成创建新对象，然后再赋值给指针。   

	" 即，每个实例都有一个指针和一个被指的动态内存区域，而不是所有实例通过指针赋值的方式共享一个动态内存"

	
    （！）三/五法则：拷贝构造，拷贝赋值，析构，这三个只要有一个是自定义的，其他两个也务必自定义，因为按照经验，
	  肯定会有风险存在。当然，这里的自定义是指需要仔细筛查风险点，而不是无脑地自定义一个空函数。


#15 ==============================================================================================================

=default 补充

只能对具有合成版本的函数使用 =default ，=default是要求编译器为我们生成默认版本的函数(包括普通函数 和 构造函数)，
如果这个函数都没有合成版本(由编译器生成)，那么=default告诉编译器，编译器才不鸟你，直接报错。


#16 =============================================================================================================

阻止拷贝

----- 方法1 -----
上面提到了，如果自己不定义拷贝构造函数，那么编译器会自动为我们生成，所以组织拷贝的方法不是不定义拷贝构造，
而是将它定义成删除函数。即使用 =delete。拷贝赋值也是如此，比如：

	A(const A& a)=delete;
	A& operarot=(const A& a)=delete;

	=delete的含义是，告知编译器  “我们不希望定义这些成员，当外部试图使用这些成员的时候，请阻止”。


	注：1） =delete可以用在所有函数上(构造，析构，普通成员函数等等)，一旦加上，程序运行到该调用函数的时候，
	    调用动作将被阻止。
	    2）虽然=delete可以用在所有函数上，但是最好不要用在析构上，一旦用在析构上，则会导致局部变量类无法创建
               ，同时new的类实例无法被删除。

----- 方法2 ------
旧办法是将拷贝构造和拷贝赋值都声明为private，并且不在cpp和h文件中实现，以此来阻止拷贝。但是现在已经弃用，请
使用方法1


#17 =============================================================================================================

当一个类的某个成员变量不能默认构造、拷贝、复制、销毁，则操作这个成员变量的成员函数都会被默认置为 =delete



#18 =============================================================================================================

拷贝控制和资源管理


按照日常使用习惯，类的拷贝动作通常分为三种：值拷贝、指针拷贝 和 不允许拷贝

大部分类对于拷贝动作的需求都是 “值拷贝” ，即每个实例都有自己的一份数据。
有些时候需要 “指针拷贝” ， 即所有实例共享同一份数据。
“不允许拷贝” ， 一般都是直接 =delete 处理，一般用来避免竞争条件的产生。


#19 =============================================================================================================

	13.4 拷贝控制的案例

#20 =============================================================================================================

	13.5 动态内存管理类

#（！）21
# =============================================================================================================

对象的移动

考虑这么一个场景：

有一个非常大的类A。而A又是另一个类B的成员变量。如果我们想拷贝B的实例B1给B2，那么就务必要

把B1中的A拷贝给B2，因为要先在B2中调用A的拷贝构造，相当于有一个临时A存在。这时就比较吃内存。

但是如果使用指针的方式，B1在析构的时候又会把A给析构掉，这时候B2就访问不到A。

但是，智能指针是可以的，但是无法实现每个B 都有自己的 实例A 。


有没有什么办法，让 B1 中的 A直接移动到 B2中去，此时B1即便销毁也无需关心？？？

新标准定义了一个新特性 ———— “对象的移动” 。 即 右值引用 && ，对比左值引用 &。

----------- 右值引用 -------------

右值引用只能作用在右值上，不能作用在左值上。如果不知道哪些是右值，对比左值即可。

（！）右值引用 && 只能绑定到一个将要销毁的对象。

语法：

	int i = 10;
	int &lr_i = i;		//正确，左值引用
	int &&rr_i = i;		//错误，右值引用不能指向左值
	int &lr_i = i*100;	//错误，左值引用不能指向右值
	int &&rr_i = i*100;	//正确，右值引用


复习一下什么是左值，什么是右值？

	左值：可以被赋值的值，指内存中一块区域的代名词，即变量名
	右值：不可以被赋值的值，是一个运算结果，不对应内存中的任何一块区域，是一个表达式

（！）可以把右值引用理解为 “给常量值或表达式值 一个标签”。

	---------

	如果我们现在已经有一个左值，那么怎么把左值的实际值作为常量赋给右值引用呢？？？

	int i = 100;
	int &lr_i = i;
	int &&rr_i = i;			//错误
	int &&rr_i = std::move(i);	//正确
	int &&rr_i = std::move(lr_i);	//正确

	我们可以使用move函数(c++11)来实现一个动作 “把左值里的值提取来，同时把左值对应的内存销毁， 然后

	把左值的值作为右值赋值给右值引用“ ，注意这里的 “提取出来”，我们可以理解 move 动作是  “把指定内存

	单元中的值提出来作为常量” ，这样就方便理解为什么是右值了。
	
	move的伴随动作时销毁左值对应的变量。即一旦调用move，下文将无法再访问变量（实际上可以，为什么？？？）

	---------


#22 =============================================================================================================

	13.6.2


#23 =============================================================================================================

#24 =============================================================================================================





















