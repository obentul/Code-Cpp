#1 ===================================================================================================

回顾：

new动作内部的三个动作：
1）调用一个名为 operator new(或者operator new[])的 标准库 函数，此函数会 向系统申请一块足够大的内存，
   且是未命名的；
2）运行指定的构造函数并进行相应的初始化
3）返回一个指向这块内存的指针


delete动作内部的两个动作：
1）调用被操作对象相应的析构函数；
2）调用 operator delete(或者operator delete[])的 标准库 函数，此函数会释放相应的内存。


数组的分配和释放，使用的是 [] 的版本。从c 和 c++ 的类型来归纳总结，其实数据可分为两大类：数组 和 非数组


#2 ===================================================================================================

我们可以通过重载 new 和 delete 来覆盖 标准库的版本。这样我们便能够自己管理内存。

可以定义全局的版本，也可以定义某个类的版本，或者名称空间限定的版本。


#3 ===================================================================================================

  PS :  操作系统一般会有自己的 new 和 delete 函数，这不同于标准库的 operator new  和 operator delete。
	
	这需要分开来记，我们能够重载的是 operatro new 和 operator delete，而不是系统函数。这两个operator

	是c++的标准库(STL)

#4 ===================================================================================================

	operator new 的底层依然是 malloc
	operator delete 的底层依然是 free

#5 ===================================================================================================

运行时识别  RTTI

运行时识别的功能由两个运算符来实现：
1）typeid，次运算符会返回入参的类型
2）dynamic_cast，把基类的指针或引用，转换成派生类的指针或引用

RTTI的用途：用来在未定义虚函数的场景下，通过typeid和dynamic_cast来模仿多态。即typeid判断实际指针类型，
	    再由dynamic_cast转换指针，最后调用非虚函数。(非虚函数跟着指针走)



typeid的用法：typeid的返回值并不是某个类型的字符串，而是一个id号，没有可读性，所以一般都是与等于号配对使用
              ，以此来判断是否是某个类型。比如：

			if(typeid(i)==typeid(int)){
				log("i is int type")
			}


#6 ===================================================================================================

typeid 的重要特性：

1）如果作用于一个指针，那么返回的是指针的实际类型，不是指针指向对象的类型
2）如果作用指针的内容(用*求值)，那么如果内容包含虚函数，那么触发运行时确定机制，即指针指向的对象是什么类型，
   那么返回什么类型。
3）如果作用指针的内容(用*求值)，那么如果内容不包含虚函数，那么不触发运行时确定机制，即取字面值类型？？？



#7 ===================================================================================================

可以定义指向 类的成员(变量/函数) 的指针。以此来跳过必须“先访问类，再访问成员”的限制。

注：这种指针不能指向静态成员


#8 ===================================================================================================

嵌套类






