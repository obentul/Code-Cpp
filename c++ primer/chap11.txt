#1  ===========================================================================================================================
智能指针

智能指针有两种： shared_ptr  和  unique_ptr

这两种指针都是模板类，因此原型为   xxx_ptr<T>


#2  ===========================================================================================================================

（！）首先明确一点，智能指针“仅仅”用来“动态分配内存”，而不是用来当做指针使用！！！！

因此：
int i = 100;	//或者其他类，比如 classA a;
shared_ptr<int> sp  = make_shared<int>(i);

上述语句实际上是使用i的值作为新分配内存的初始值。sp并没有指向i，而是指向了新分配的堆，这个堆存放int型的数值100

上述语句不能算错误，但是需要理解  make_shared 动作实际上是取堆里申请了内存的。

	(可以这样理解，make_shared相当于 new ，尖括号指定需要分配内存的类型名，小括号指定作为拷贝构造传递给
	  类型名的值，如果不指定，那么使用类型的默认构造)


同理：
classA *pa = new classA();
shared_ptr<classA> sp = make_shred<classA>(*pa);	//使用classA的拷贝构造在堆里创建一个新的对象，而不是使用pa指向的对象


====== EXAMPLE 1 =======

#include "stdafx.h"
#include <iostream>
#include <memory>
using namespace std;

class A{
public:
	A() = default;
	~A(){ ; }
public:
	int myint=10;
};

int _tmain(int argc, _TCHAR* argv[])
{
	A* pa = new A();
	shared_ptr<A> sp = make_shared<A>(*pa);
	sp->myint = 100;

	cout << pa->myint << endl;		//pa = 10 ，值并没有改变，因为它是用 new 分配的堆
	cout << sp->myint << endl;		//sp = 100，值和pa不一样，因为它是用 make_shared 分配的堆

	getchar();

	return 0;
}

	注：小括号里的内容必须与尖括号里类型的某个构造函数相匹配


====== EXAMPLE 2 ======

#include "stdafx.h"
#include <iostream>
#include <memory>
using namespace std;

class A{
public:
	A() = default;
	~A(){ ; }
public:
	int myint=10;
};

int _tmain(int argc, _TCHAR* argv[])
{
	shared_ptr<A> sp = make_shared<A>();		//使用 A 的默认构造函数

	cout << sp.use_count() << endl;				//为1

	shared_ptr<A> sp1 = sp;						//增加了sp指向内存区的计数

	cout << sp.use_count() << endl;				//为2 
	cout << sp1.use_count() << endl;			//为2

	sp1 = NULL;

	cout << sp.use_count() << endl;				//为1

	getchar();

	//小结：可见智能共享指针的计数器是由系统自动管理的，具体内部实现可能是 静态数据类型，这样各个
	//		实例操作的就是同一个数据，当然，可能会涉及到线程安全的问题，这时候就要加锁，这也伴随着
	//		效率略低和死锁的风向

	return 0;
}

#3  ===========================================================================================================================

（！）在使用共享指针时，我们只需要操作指针对象，不要试图去直接操作指针指向的内容。因为当所有指针都销毁的时候，动态分配的内存会被
自动释放。


计数增加：
1）初始化一个shared_ptr
2）作为参数传递给一个函数
3）作为函数返回值

计数减少：
1）给shared_ptr新指向对象，替换旧对象，那么就对象计数减少
2）shared_ptr调用析构函数，比如局部变量离开作用域等等


	小结：shared_ptr将对对象的内存管理转变为对对指向对象指针的管理。而这个指针的获得仅能通过shared_make来实现。因此，从
	      某种意义上来说，更集中。
	      

#4  ===========================================================================================================================

共享指针的应用场景：
1）程序不知道自己需要多少个对象？？？
2）程序不知道所需要对象的准确类型？？？
3）程序需要在多个对象之间共享数据，这有点像类的static成员变量，是所有类共享的。但是既然有static，为什么还要共享指针？？？


（！！！）使用动态内存的一个常见原因是：允许多个对象共享相同的状态。

（！！！）为什么不做成static的？
主要因为static数据存放在.bss区，无法手动释放，在程序运行时就载入，而这部分的可用空间是有限而狭小的。如果我们想要使用堆栈这样
宽敞的空间来模拟static成员，此时就可以使用共享指针管理的动态内存(堆)来实现，实现一个仅在大家都不在需要时才会释放的堆区域。


#5  ===========================================================================================================================

https://www.cnblogs.com/yinbiao/p/11563520.html

引用计数法的内部实现:

  1）这个引用计数器保存在某个内部类型中，而这个内部类型对象在shared_ptr第一次构造时以指针的形式保存在shared_ptr中

  2）shared_ptr重载了赋值运算符，在赋值和拷贝另一个shared_ptr时，这个指针被另一个shared_ptr共享

  3）在引用计数归0时，这个内部类型指针与shared_ptr管理的资源一起释放

* 4）此外，为了保证线程安全，引用计数器的加1和减1都是原子操作，它保证了shared_ptr由多个线程共享时不会爆掉

#6  ===========================================================================================================================

一个典型的场景：

class A{

public:
    vector<classB> m_B_list;		//非常庞大的一个列表（实际这里可以使vector指针，这里只是做一个描述）

}

如果A有N多个实例，问题就出现了，每个A实例都要有一个m_B_list，首先很吃内存，其次各个A实例之间需要实施互相同步数据，从而保证这个
vector对于所有A来说，都是一样的。这是很棘手和难处理的：
1）可以让vector是static的，但是这样比较占用static区域，而且无法释放   					（不可选）
2）可以简单粗暴，让所有A在更改vector之后，通知其他A跟新自己的vector，这样既 占内存，又 占CPU 		（不可选）
3）创建一个command管理类，让command管理类来存放vector，并提供增删改查接口给所有A使用，这样保证了效率，一定程度上节约了内存。
   但是，需要新增一个类，而这个类的存在感很低，因为它只是来做一个中转					（不是最优解）
4）不创建command管理类，但是在外部区域创建vector，然后让A都能访问，这样有风险，如果某个A出于“某种原因”把vector给删掉了。
   那么其他A在访问的时候将访问到空指针，或者直接崩溃。这种情况特别是在A都存放vector指针是明显，因为析构时会释放成员变量。（不是最优解）

*5）使用shared_ptr，vector不使用new创建，而是使用shared_make，在A构造的时候创建。但是需要注意各个A运行在不同的线程下，同时
    操作vector可能产生竞争。


第一种实现为 =============

	---A.h---
	class A{
	public:
	    A();	
	    A(shared_ptr<vector<classB>> tmplist);


	public:
	    shared_ptr<vector<classB>> m_p_B_list;

	}

	---A.cpp---
	A::A():m_p_B_list(make_shared<vector<classB>>()){		//默认构造，列表初始化

	}
	A::A(shared_ptr<vector<classB>> tmplist):m_p_B_list(tmplist){

	}

（？？？）上面的实现虽然使用了共享指针管理动态内存，但是多个A如果都使用默认构造的话，实际上还是创建了多个vector实例，然后各个A
	  管理自己的vector


#7  ===========================================================================================================================

12.1.2 直接管理内存


#8  ===========================================================================================================================

#9  ===========================================================================================================================

