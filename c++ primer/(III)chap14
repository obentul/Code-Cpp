
运算符重载 ，从本质上来说还是函数调用，因此，对于参数个数和返回值没有一定的形式，比如

加号运算符的重载甚至可以有两个以上的入参，只需要调用者知道用法，因为这个时候就只能用

函数式的调用方法，而不是运算式。当然，这也违背了运算符重载的初衷。所以在设计时务必遵循

函数运算符的本意，而不是为了使用技巧而使用技巧。


#1 ==================================================================================

如果重载运算符是成员函数，那么默认运算符的左侧操作数是 this指针，即调用者。因此，重载
运算符的操作数都比参数列表多一个，因为左侧操作数省略了。

#2 ==================================================================================

重载运算符的调用有两种：

calss A{
public:
  operator+(const A&);
}

1）  a1.operator+(a2);		//函数式
2)   a1+a2;			//运算式

#3 ==================================================================================

不建议对某些运算符进行重载，比如 逻辑与(&&),逻辑或(||),逗号运算符(,)。原因在于，这些
运算符有附加操作，比如 && 和 || 都有短路特性，如果确实需要重载，那么务必保证把短路特性
一并时间，这样可以与内置操作保持一致而避免潜在风险。

另外，像取值(*) , 取地址(&) 这样的运算符也不要重载，因为编译器已经是重载了一遍了，再
进行重载可能会产生混乱，而且本来就很复杂。

	注： ‘||’  ‘ &&’  ‘&’  ‘，‘   这四种不要重载

#4 ==================================================================================

复合运算符： +=   ++  -=   -- ，这四种，必须要定义赋值运算符 = ，因为他们都会进行赋值动作。

#5 ==================================================================================

运算符重载既可以是 类的成员函数，也可以不是，而是存在于类作用域范围之外，以全局函数的
形式存在。

那么如何判断哪些运算符应当/适合是成员函数？？

除了双侧操作数类型不统一且可以互换的场景，其他任何场景下，都可以是成员数，因为双侧
操作不统一且可互换，就没法判断 运算符 的左侧操作数 this 到底是什么类型。

#6 ==================================================================================

输入 <<   和   输出 >>  的重载

#7 ==================================================================================

自定义的类是没有 == 运算的，需要自己重载 == 来实现业务逻辑，同时指明什么样的情况下两个
实例是相等的。

== 和 != 一般是同时存在的，从使用习惯上来说肯定是对立的(除非真的想与众不同而写出让人费解
的代码)，因此，往往只需要实现其中一个的业务逻辑，另外一个调用已经实现的那个便可。


#8 ==================================================================================

赋值运算符：

除了 拷贝赋值 和 移动赋值，还有一类赋值 --> 初始化参数列表，例如：

A& A::operator=(initializer_list<string> il){


}
	
#9 ==================================================================================

复合赋值运算

+=，-= ，因为这种运算符的使用习惯往往是相同类型的相加，所以一般定义成
成员函数（两侧的运算对象类型一致）。原型模板：

	A&  A::operator+=(const A& tmp){

		...
		return *this;

	}

#10 ==================================================================================

下标运算符

下标运算符一般都会定义两个版本：

string& operator[](int n){
	return element[n];
}
const string& operator[](int n)const{
	reutrn element[n];
}

#11 ==================================================================================

自增 和 自减   ++a,a++,--a,a--

一般定义成成员函数，注意这四种运算符的赋值和自增的顺序，在实现是请模仿一遍兼容通用版本

既然都是 ++ 和 --，那么在定义时的区分方式如下：

A& A::operator++();		++a
A& A::operator--();		--a
A& A::operator++(int);		a++
A& A::operator--(int);		a--

这里的int仅仅用来告知编译器是后置，实际使用中请忽略，这个int不是形参

如果希望使用“函数式”调用后置自增，只需要把int位置替换成0，即 a1.operator++(0)


#12 ==================================================================================

箭头运算符 ： ->

一般定义成成员函数，因为它必定会使用this指针


#13 ==================================================================================

函数调用运算符

operator()(int);

（*）如果一个类定义了函数调用运算符，那么这个类可以被当做函数来使用，即实例名可以当做函数来使用。

A a1;
a1(10);		//直接把实例名当做函数使用

函数运算符的重载函数必须是成员函数，同时一个类可以通过入参结构的不同来实现进一步的重载。



 （！）ps：可以把一个类定义为函数功能型类，这个类有一些基本的成员（static/非static）来记录状态，
	       然后又N个重载了()的函数，这样的类就很像 “ 状态机 ”，既能够记录当前的状态，
		又能够根据当前的状态提供不同的服务。

#14 ==================================================================================

复习lambda 表达式


格式：    
[capture list](parameter list)->return type{funticon body}

capture list : 表达式所在作用域的局部变量，逗号隔开，必选可以为空
parameter list : 调用表达式时可以传入的参数，可选
->reutrn type : 返回值类型，可选
function body : 函数体，必选可为空

例子：

	void funciton(int a,int b){
	
	    int c=99,d=11;
	    auto f = [c,d](i,j)->int { return max(a,b,c,d);}

	    int ret = f(a.b);	//a,b作为入参，c,d作为捕获列表，获取啊，a,b,c,d中最大的那个

	}


编译器会将lambda表达式翻译成“ 一个未命名类的一个未命名实例 ”，并且这个未命名类中自带
函数调用运算符的一个重载版本，而这个重载函数的内容正是lambda的内容。


#15 ==================================================================================

（！！！）function类型

可以通过function来申明可调用对象(函数，重载()的类，lambda表达式，函数指针，bind创建的对象)
的类型，对于lambda这种没有明确类型的可调用对象非常有用。

例子：
	如果我们想定义一个函数表， map<string/*函数名*/,int(*)(int,int)>。即一个
	有 “函数名字符串“ 和 ”int返回值，两个int入参的函数指针“ 组成的map表。

	此时lambda就不能插入这个表中，因为虽然形如 [](int a,int b){...}的lambda表达式
	在入参和返回值都和 int(int,int)匹配，但是lambda是无类型的。那么此时可有通过
	function来修饰：
		function<int(int,int)> f1 = [](int a,int b){....};
		map.insert("lambdafunc",&f1);  //这里因为接受的函数指针，故做一个取地址运算

#16 ==================================================================================

类型转换运算符的重载

例:
	float i;
	int j = (int)i;

   需要时在看  14.9



























