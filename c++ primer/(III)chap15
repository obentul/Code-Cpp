#1 ===================================================================================

面向对象的程序设计基于三个概念：数据抽象、继承和动态绑定

#2 ===================================================================================

继承 和 动态绑定 存在的意义：
1）更容易地定义与其他类相似但不完全相同的新类;
2）使用这些相似的类编写程序时，可以在一定程度上忽略他们的区别。

#3 ===================================================================================

基类将哪些希望派生类自定义版本的函数定义为虚函数，用virtual修饰。


#4 ===================================================================================

动态绑定即 ”多态“

当使用基类指针调用一个虚函数的时候，将会产生多态现象

#5 ===================================================================================

如果是public继承，那么派生类可以访问基类的所有资源(public,protected,private)，仿佛在访问自己的 

如果是protected，则只能访问public 和 protected

如果是private，则只能访问public

#6 ===================================================================================

虚函数：除了构造函数，静态函数，其他任何函数都可以是虚函数

#7 ===================================================================================

基类访问说明符有三种：public，protected，private。

这个说明符用的作用：表示派神类是否能看见那些他从基类继承来的成员（函数，变量）

如果是public继承，那么基类的的public成员将会成为派生类的public成员。同时，基类指针能指向派生类。

#8 ===================================================================================

一个派生类实例包含多个实例： 一个自己的类实例 ; 一个基类的实例 ; 如果多继承，则基类实
例是多个，所以，至少有两个实例。


c++标准没有规定派生类中的各个实例是如何分布的。类自己的实例 和 基类的实例 在内存空间
不一定是连续的。


（！！！）在派生类实例中包含了一个基类实例，这是继承的关键。因此，我们可以通过基类指针
和基类引用来指向派生类中的基类部分。

#9 ===================================================================================

派生类的初始化顺序：先初始化基类（根据参数列表决定使用基类的哪个构造），然后按照成员
		    变量的声明顺序依次初始化。

#10 ===================================================================================

派生类可以使用基类的 public 和 protected 成员


	557	派生类使用基类的成员



