#1 ===================================================================================

面向对象的程序设计基于三个概念：数据抽象、继承和动态绑定

#2 ===================================================================================

继承 和 动态绑定 存在的意义：
1）更容易地定义与其他类相似但不完全相同的新类;
2）使用这些相似的类编写程序时，可以在一定程度上忽略他们的区别。

#3 ===================================================================================

基类将哪些希望派生类自定义版本的函数定义为虚函数，用virtual修饰。


#4 ===================================================================================

动态绑定即 ”多态“

当使用基类指针调用一个虚函数的时候，将会产生多态现象

#5 ===================================================================================

如果是public继承，那么派生类可以访问基类的所有资源(public,protected,private)，仿佛在访问自己的 

如果是protected，则只能访问public 和 protected

如果是private，则只能访问public

#6 ===================================================================================

虚函数：除了构造函数，静态函数，其他任何函数都可以是虚函数

#7 ===================================================================================

基类访问说明符有三种：public，protected，private。

这个说明符用的作用：表示派神类是否能看见那些他从基类继承来的成员（函数，变量）

如果是public继承，那么基类的的public成员将会成为派生类的public成员。同时，基类指针能指向派生类。

#8 ===================================================================================

一个派生类实例包含多个实例： 一个自己的类实例 ; 一个基类的实例 ; 如果多继承，则基类实
例是多个，所以，至少有两个实例。


c++标准没有规定派生类中的各个实例是如何分布的。类自己的实例 和 基类的实例 在内存空间
不一定是连续的。


（！！！）在派生类实例中包含了一个基类实例，这是继承的关键。因此，我们可以通过基类指针
和基类引用来指向派生类中的基类部分。

#9 ===================================================================================

派生类的初始化顺序：先初始化基类（根据参数列表决定使用基类的哪个构造），然后按照成员
		    变量的声明顺序依次初始化。

#10 ===================================================================================

派生类可以使用基类的 public 和 protected 成员

基类的static成员依旧是唯一一份，不会因为有多少个派生类而增加。

#11 ===================================================================================

基类必须是已经定义的类，光声明不行。

#12 ===================================================================================

如果希望指明 某个类一定不会作为基类，那么在声明的时候使用final关键字。

 class A final{
     ...
 }

#(!!!)13 ===================================================================================

需要明确：类型转换 dynam_cast,const_casst,...  这些类型转换，”仅仅只能用在指针 和 引用” 上，
不能对 类实例进行转换， 即不能把 基类实例转换成 派生类实例，也不能把派生类实例转换成基类实例。

这就引入一个问题，在定义那些形参为派生类的函数时，一定要让形参是 “ 指针 ”或者 “ 引用 ”，否则，
这个函数将无法支持隐式转换，降低了灵活性。


#14 ===================================================================================

可以使用 派生类实例 来初始化基类实例，此时会用派生类中的基类部分来初始化基类实例，派生类
部分将被忽略。

	注：上述操作仅仅在基类定义了 拷贝/赋值 构造的情况下可行，因为这种初始化
	    实际上相当于调用了基类的 拷贝/赋值 构造。

class A{
public:
   A()=default;
   A(const A&);
   A& operator=(const A&);
}

class B:public A{
public:
   B()=default;
}

B b1;

A a1(b1);	//编译器会把 B 的引用 隐式转换成 A的引用，派生类向基类的 指针/引用 转换，
		//相当于调用基类的拷贝构造

A a2 = b1;      //相当于调用基类的赋值构造


#15 ===================================================================================

多态的由来：使用类型的“多种形式”而无需在意他们的差异。

指针/引用的静态类型 在定义是确定，但是其指向的内容需要在运行时判断，即动态类型，所以指针
的这个特性便是多态的基础。

#16 ===================================================================================

多态场景下，函数的绑定：

非虚函数：编译时绑定
实例+虚函数：编译时绑定
基类指针/基类引用 + 非虚函数：编译时绑定
基类指针/基类引用 + 虚函数：运行时绑定

   小结：当且仅当 基类指针/引用 进行虚函数调用时，才会在运行时做动态绑定。

#17 ===================================================================================

某个函数如果是虚函数，那么派生类对应的版本都是虚函数，无需再次通过virtual取声明

#18 ===================================================================================

orverride：当前函数时对基类虚函数的实现，如果形参列表和基类虚函数不匹配，则编译器报错。
final：表示当前虚函数当此处停止，子类再继承只会得到非虚版本。如果子类尝试实现这个虚函数，
       则编译器报错。

#19 ===================================================================================

虚函数可以有默认实参，但是，即便派生类有自己的默认实参，在使用使用基类指针调用时还是会
使用基类的默认实参。反之，如果使用派生类指针调用，则会使用派生类的默认实参(当然这就不
设计多态了，因为调用指针/引用是派生类，而不是基类)。

class A{
public:
	A()=default;
	virtual ~A()=default;
public:
	virtual void func(int i = 10){
		printf("A = %d\n",i);
	}
};

class B :public A{
public:
	B()=default;
public:
	void func(int i = 20){
		printf("B=%d\n", i);
	}
};

int _tmain(int argc, _TCHAR* argv[])
{
	A a1;
	B b1;

	A* p1 = &b1;
	B* p2 = &b1;

	p1->func();		//10
	p2->func();	    //20

	getchar();
	return 0;
}


#(!!!)20 ===================================================================================

规避虚函数的动态绑定

如果我们希望明确指定调用 基类 还是 子类的虚函数版本。那么可以通过作用域运算符 :: 


class A{
public:
	A()=default;
	virtual ~A()=default;
public:
	virtual void func(int i = 10){
		printf("A = %d\n",i);
	}
};

class B :public A{
public:
	B()=default;
public:
	void func(int i = 20){
		A::func();				//在派生类中调用基类的版本
		printf("B=%d\n", i);
	}
};

int _tmain(int argc, _TCHAR* argv[])
{
	A a1;
	B b1;

	A* p1 = &b1;
	B* p2 = &b1;

	p1->A::func();		//虽然p1指向的是派生类实例，但是通过作用域限制，要求其调用基类的版本
	p2->func();			//虽然p2是派生类指针，但是派生类的虚函数实现中，会先调用基类的实现

	getchar();
	return 0;
}


	小结：这个特性非常有用，当很多派生类 都用相同动作时，我们可以把这些动作合成一个虚函数放
	      在基类中，然后大家一起继承并实现虚函数，然后各自在进行自己的特有业务之前，先使用
              这个方法调用基类的版本。


（！！）注意：不能再基类中访问派生类的虚函数版本，因为基类是派生类的子集，作为内存中的实例，它是没有
               任何派生类的实例的，因此无法访问，不过public的statitc方法除外。

#21 ===================================================================================
	      
纯虚函数

纯虚函数不需要也不能有函数体，同时，纯虚函数的标志=0必须用在类定义(.h)时。

我们可以在cpp文件中给纯虚函数以实现，但是不能使用=0。（这样做有什么意义？？？）


#22 ==================================================================================

含有纯虚函数的类是抽象基类。

抽象基类不能实例化。

#23 ==================================================================================

基类通过访问控制来 限制其派生类对自己成员的访问。

（！）友元函数/友元类，不具备传递性，派生类的友元只能访问派生类的成员，不能访问基类的成员，
即便是基类中那些可供派生类访问的protected成员。


#（!）24 ==================================================================================

接#23

派生类 对基类成员的 访问能力 ，取决于两个因素：

1）基类中成员的访问权限
2）继承时，使用的继承权限


派生类对基类成员的访问权限，与是public 、 protected 、 private继承没关系。仅仅与基类中
成员的权限属性有关系：派生类能访问基类的public和protected成员，不能访问private成员。

继承权限是用来控制 “派生类的使用者” 对基类成员的访问权限。


	注：这里涉及到两个概念：1）派生类对基类成员的访问权限
				2）派生类使用者对基类成员的访问权限

类成员的使用者有三种：1）自己的其他成员，比如成员函数可以使用成员变量，不管成员变量是
			 什么权限，注意，这里的使用仅限在这个类的实现中，通过类实例
			 来访问，这属于类使用者的访问，而不是类自身的访问
		      2）派生类，派生类的实现(成员函数、成员变量)能够访问它基类的protected
			 和public成员
		      3）派生类的派生类（孙类） 和 其他类，如果派生类是public继承基类的
			 ，那么这两种类都可以“ 通过多态 ”直接访问基类的public成员。如果是
			 private的，那么无论如何都不能 “ 通过多态 ”直接访问基类的任何成员，
			 包括public的，当然，你可以直接通过基类指针来访问。


#（!！！）25 ==================================================================================


（！）目前已知场景有两个：

-----------  1  ------------

通过private继承，来控制孙类对基类的成员访问。
	      
private继承可以理解为：可传家产（public）到儿子辈就被截住了，孙子辈用不到爷爷辈的东西。
public继承可以理解为：可传家产（public）儿子辈一点没动，孙子辈可以接这用爷爷辈的东西。

即：哪一层继承做了private限制，对上一层的访问就在哪一层停止，后续的继承都没法突破这层
    限制。

每一层只能控制自己下一层对自己上一层的访问，而自己永远都能够访问上一层的public东西。

-----------  2  ------------

通过private继承，来控制类使用者通过基类指针指向派生类。

例：
	class A{
	    ...
	}
	class B:private A{
            ...
	}
	main{
	    A* pa;
	    B b;
	    pa = &b;	//如果是private继承，则词句编译不过，public继承就可以
			//因为这里是main函数这么一个类使用者试图通过派生类指针来访问基类成员
			//同理，如果这里不是main函数，而是类外一个类C，同样也允许，因为他们
			//对于 A  和 B来说都是使用者。
	}



--------  （！！！）再次回顾  ----------

1）成员变量的权限，是用来控制  子类  和  使用者对自己成员的访问
2）继承权限，是用来控制  自己的子类  对 自己的父类 的 “”“”public”““”成员的访问，
   注意这里说的是public成员，因为无论如何都无法访问private成员
	（为了简单只讨论  public和private ， protected自己类推）


#26 ==================================================================================

友元不具备传递特性，即基类 的 友元对于派生类没有友元属性，不能访问派生类private成员。

但是！！！因为可以在派生类中调用基类函数(通过域访问符 :: )，所以有时候会发现在派生类中
会出现“使用基类友元来访问基类”的代码，看起来有点另类，但是确实是合法且符合常理的。毕竟
“我（友元）虽然在你（派生类）的地盘，但是我（友元）打的是我自己的孩子（基类），虽然
这个孩子可能是派生类的爸爸....”。

可以理解为 “爸爸(基类)的领导(基类友元)管不到儿子(派生类)” 


#27 ==================================================================================

如果想要在私有继承时搞个特例怎么办？

比如 A 私有继承了 B，但是A又想开让用户能直接访问B的某个成员，那么：
1）首先保证基类的这个成员是public的（protected场景自己脑补）
2）其次在派生类中这样声明   public:
				using A::func;		//注意，这里只有函数名，没有参数列表

即通过using来说明派生类的某个成员其实是使用基类的版本。

同理类比protected场景

	（！）这里依旧无法绕过 “基类的private成员永远无法访问” 这个限制。

#28 ==================================================================================

可以简单理解为：

“  使用哪种继承，就会把基类的public成员变成自己的 哪种成员  ，而 类使用者 和 继承自己的
   的类只需要依旧按照成员访问权限来访问自己即可   ”。


		常用的场景就是#25的那两个

#29 ==================================================================================

一种错觉：认为在使用struct 关键字 和class关键字定义的类之间存在某种深层次的差别，实际上，

	  “ 仅仅是成员的默认访问权限 及 默认的继承权限 不一样”，仅此而已。

struct在权限控制上，默认都是public
class在权限控制上，默认都是private

#30 ==================================================================================

派生类 和 基类的作用域

派生类的作用域(大括号)在基类作用域之内，这意味着派生类可以访问基类的成员，而基类不能访问
派生类的成员。例如：

	 func(){		//基类作用域
	   int i;

	   {			//派生类作用域
		int j = i;	//正确
	   }

	   j++;		//错误

	 }

（！）在 编程中，看起来越小的作用域，其访问范围越大，看起来越大的作用域其访问范围越小。

#31 ==================================================================================

正如同#30中描述，派生类的作用域在基类作用域之内，那么如果基类的成员和派生类的成员重名，
那么在派生了中使用重名成员，将优先使用派生类的，因为遵循 “ 就近原则 ”。当然，我们可以
通过域名访问运算符 :: 来指定使用基类的重名变量。

#32 ==================================================================================

成员函数的调用流程：

A a;
A *pa = &a;
a.func();
pa->func();

1）首先确定a/pa的静态类型(即定义时的类型)。
2）其次在1）的静态类型定义中查找对应的成员(这里是func())。如果找不到，那么去它的基类中
   找，如果还没找到，再去基类的积累中找。最终都没有找到，则编译器报错。
3）如果知道到了，判断是否能调用（参数是否匹配，访问权限是否足够，继承权限是否有限制...），
4）假如3）合法，那么编译器再判断是不是进行了虚函数调用（func是不是虚函数）：
	a）如果是虚函数，而且是通过指针和引用在调用(多态仅仅在基类指针/引用的场景下
           才存在)。如果是，则根据当前指针指向的实例来调用虚函数版本(即动态绑定)。
	b）如果不是虚函数，那么什么指针就掉什么类型的函数。

#33 ==================================================================================

using的巧用

c++并没有要求基类的每个虚函数都要在派生类中实现，但是有些时候我们把基类的这些虚函数都
在派生类中描述一下（方便使用者查看），但是一旦我们把虚函数声明出来，那就意味着我们做了
重载动作，此时就逼得我们不得不写出自己的虚函数重载版本，但是很多时候我们还是想使用基类
版本，那么此时就有两种方案：
1）在派生类的重载版本中使用域访问运算符调用基类版本
	class A{
		virtual void func(){
		}
		virtual void func(int){
		}
	}
	class B:public A{
		void func(){
			A::func();
		}
		void func(int i){
			A::func(i);
		}
	}
   可以看到，如果基类虚函数有N个，那么派生类就要写N次，这明显很啰嗦，2）便可以
   使用大粒度的控制来进行粗糙的批量映射。

2）使用using来进行说明，参见#27
	class A{
		virtual void func(){
		}
		virtual void func(int){
		}
	}
	class B:public A{
		using A::func;		//注意，这里仅仅是函数名
					//这一个动作就代表所有名为func的虚函数都
					//使用基类版本，相当于创建了一个 “软连接”
					//然而使用时还是要根据参数列表来判断使用基类的哪个版本
	}

#34 ==================================================================================


	#15.7 构造函数与拷贝控制 





























