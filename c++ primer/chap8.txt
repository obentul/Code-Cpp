#1  ==================================================================================================

vector     	可变大小的“数组”			增加删除头尾位置数据慢
deque      	双端队列				增加删除头尾位置数据快，在中间位置添加和删除数据慢
list	   	双向链表				顺序访问快，随即访问慢，插入操作快
forward_list	单向链表				同上
array		固定大小数组				“不能增删元素”
string		只保存字符的vector


vector和string都能使用下标来操作，他们的底层都是数组


#2  ==================================================================================================

（！）迭代器的end不是指向容器的最后一个元素，而是最后一个元素的下一个内存位置。
      因此不能访问迭代器的end元素，比如：

	vector<int> i = {1,2,3,4,5};
	vector<int>::iterator it_1 = i.begin();
	vector<int>::iterator it_2 = i.end();

	cout << *it_1;		//1
	cout << *it_2;		//未知值
	cout << *(it_1+(i.size()-1));		//访问最后一个值


	ps：一般不用迭代器来访问指定元素，迭代器一般用作轮询



迭代器区间为 [begin,end)


（！）从迭代器的声明可见，迭代器是指定容器中的一个“类内类型”


迭代器的四个版本：
list<int> a={1,2,3,4};

//1 - 普通版本
auto it1 = a.begin();
list<int>::iterator it2 = a.begin();

//2 - 反向版本
auto it3 = a.rbegin();
list<int>::reverse_iterator it4 = a.rbegin();

//3 - const版本，只能通过迭代器读，不能写
auto it5 = a.cbegin();
list<int>::const_iterator it6 = a.cbegin();

//4 - 反向const版本
auto it7 = a.crbegin();
list<int>::const_reverse_iterator it8 = a.crbegin();



#3  ==================================================================================================

容器的定义和初始化

如果容器元素有默认构造函数，那么使用指定大小的容器初始化方法时，可以仅指定大小即可。
如果容器元素没有默认构造函数，那么使用指定大小的容器初始化方法时，除了需要指定大小外，还要指定一个
默认的初始值，以此告知如何初始化容器中的每个元素。

vector<myclass> i(10);		//myclass有默认构造函数，这条语句会创建一个vector，有10个元素，
				  每个都使用默认构造函数来初始化。
vector<myclass> i(10,"123")	//myclass如果没有构造函数，这条语句创建的10个元素，都会使用“123”来
				  进行初始化，需要myclass有如下构造函数 myclass(string);

#4  ==================================================================================================


array的初始化

array和其他容器不同，它必须指定容器大小，因为array是固定大小的。所以array在声明的时候就必须指定大小值。

如果array的元素是类，那么这个类必须有默认构造函数。


#5  ==================================================================================================

difference_type 类型只接受两个 迭代器的加减运算

	vector<int>::iterator it_1 = i.begin();
	vector<int>::iterator it_2 = i.end();
	vector<int>::difference_type count = it_1 - it_2;	//负值，因为begin在end之前

#6  ==================================================================================================

容器的赋值

vector<myclass> v1,v2;

v1.swap(v2);	  //v1 和 v2内容互换，（！）v1，v2内部元素类型必须一样
swap(v1,v2);	  //同上



vector<myclass>::iterator it1 = v2.begin();
vectro<myclass>::iterator it2 = v2.end();
v1.assign(it1,it2);	//使用it1和it2中间的内容，替换v1中的内容
v1.assign(10,"123");	//使用10个myclass填充v1，每个都使用“123”来初始化，（！）myclass需要有myclass(string)构造

注：assgin的调用者 不能是 入参。比如 v1.assign(v1.begin(),v1.end());

#7  ==================================================================================================

关于swap的一些重要说明

array<int> a1(10);
array<int> a2(8);
int *p = &a1[2];

vector<int> v1(10);
vector<int> v2(8);
int *p = v1[2];


array	 :	swap会对两个容器的值进行互换，如果指针指向了a1的第二个元素，那么在进行了值互换后，
		指针还是指向a1的第二个元素，只是其中的值变了，变成了a2的第二个元素值。

其他	 :	swap不再交换容器值，而是交换两个容器的标签(容器名)，这就意味着交换前后，访问相应
		的内存地址，会发现值没变。如果指针指向了v1的第二个元素，那么交换后，指针指向的
		依旧是原先v1的第二个元素，只不过此时这个元素已经是v2的第二个元素了(因为容器名称
		发生了互换)


	注：只要记住一点，对于array 和 other<string> 两种情况，会发生互相赋值。会导致内存地址
	    中的值发生改变，其他情况下，内存地址中的值不改变。


同理，引用 和 迭代器 与指针有同样的结论。

小结：为了安全使用，还是在swap之后，进行指针、引用和迭代器的重新赋值。

ps：swap的这个特性可以用来实现高效的代码，但是也是高风险的代码

#8  ==================================================================================================

容器的max_size()函数，返回系统当前所能容纳的最大数量的当前容器。

#9  ==================================================================================================

容器的比较

仅相同类型的容器能相互比较。

容器的比较和字符串的比较类似。

#10  ==================================================================================================

   向顺序容器中增加元素


（！）向一个vector或string添加元素可能引起整个对象存储空间的重新分配，因为此二者都是数组，数组需要连续的
存储空间，如果追加数据时可能踩踏其他变量，则系统会重新分配一块内存。


 ==== 尾部追加元素 ====

c.push_back(t)			//在尾部增加一个值为t的元素
c.emplace_back(args)		//在尾部增加一个元素，这个元素原地构造，使用的构造函数由args列表确定
				// 比如，想使用默认构造，则args为空；想使用拷贝构造，则args为一个实例；
				//	 想使用A(string,int)，则c.emplace_back("123",10)

例子：
	class A{
	   public:
		A()=default;
		A(string s,int i){
		   ....
		}
	}

	...

	vector<A> v(10);		//使用A的默认构造初始化一个vector容器v
	v.emplace_back("123",10);	//为v的尾部增加一个元素，这个元素有A的构造函数A(string s,int i)创建

	A a;				//创建一个A的实例a，使用A的默认构造函数
	v.push_back(a)			//（！）使用a实例创建一个新的实例，追加到v的尾部


（！！！）当我们使用一个对象来初始化容器时，或将一个对象插入到容器中时，实际放入到容器中的一个值的拷贝，而
不是对象本身（这就不用担心临时变量释放的问题）。因此向容器中插入添加一个对象后，即便修改原始对象，也不会
影响容器中的内容，因为是两份数据。


（！）array和forward_list不支持push_back动作。
1）array不支持是因为array是固定大小数组，不支持扩容操作。
2）forward_list不支持是因为在单向链表的尾部增加数据效率非常低，需要遍历整个链表，所以STL建议使用list，故
索性就不支持在链表尾部增加数据


 ==== 在首部添加元素 ====

仅list、forward_list 和 deque 支持在容器首部增加元素，使用push_font函数

类比在尾部追加元素，与之配对的是emplace_font


 ==== 在容器中间位置插入元素 ====

vectro 、 deque 、 list 和 string 支持insert动作，配套的函数为 insert 和 emplace ，这两个函数接收一个
迭代器参数，用来指明在何处插入(这点没有Qt的库好用)，插入位置为迭代器指向位置的前一个位置

（！） insert的返回值为一个迭代器，这个迭代器指向新插入的位置。有些时候可以通过这个特殊的返回值来
       执行一些特殊操作

 
 insert动作有四种格式：
 1）c.insert(p,t)		//在迭代器p指向位置的前一个位置，插入一个元素t
 2）c.insert(p,n,t)		//在迭代器p指向位置的前一个位置，插入n个元素，每个元素的值都是t
 3）c.insert(p,b,e)		//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx，插入迭代器b和迭代器e之间的所有元素，闭区间
 4）c.insert(p,il)		//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx，插入初始化列表中的元素，il是 {x,x,x,x}			


#11  ==================================================================================================
