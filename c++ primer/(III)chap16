#1 ======================================================================================================

函数模板：我们提供函数实现的样例，”在编译时“，编译器根据模板的使用情况，自动将模板转换成合适的实体。

我们理解为 ”类“ 和 ”实例”的关系，模板是类，使用过程中形成的函数实体则是实例

#2 ======================================================================================================

语法：

	template <typename T1,typename T2>			//这里最少要有一个模板参数类型
	int func(const T1& v1 , T2 v2 , int v3)
	{
	
		...

	}


#3 ======================================================================================================

编译器用实参的类型来为模板实例化一个 “函数实例” 。

承接#2 

	int i;  string s;
	vector<int> v_i ; vector<string> v_s;

	func(i,s,100);			//编译器会使用int作为 T1，string作为T2
	func(v_i,v_s,100);		//编译器会使用vector<int>作为 T1，vector<string> 作为T2


编译器会根据模板参数列表 和 实参的入参类型 来进行模板的实例化。
在上例中，编译器会为我们创建两个函数实例，而这些动作 “在编译时就已经完成” 。
	

#4 ======================================================================================================

在模板参数列表声明 中，一定要使用typename来修饰模板类型，比如：

	template <typename T,typename U>	//正确
	template <typename T,U>			//错误


#5 ======================================================================================================

inline 和 constexpr 的函数模板

inline 和 constexpr 需要放在参数列表后面：

	template<typename T>inline
	//template<typename T>constexpr
	T func(T){
		...
	}

#6 ======================================================================================================

模板函数 / 模板类 的定义通常放在头文件中

#7 ======================================================================================================

正如 #3中描述

模板函数的形参列表中可以有明确的类型（内置类型，自定义类型），所以这也要求这些类型需要在模板之前提前声明。


	class A;			//A要前置声明
	template<typename T>
	void func(T t,A a);

又，模板通常定义在 头文件中，那么模板的定义者一般还要提供一个头文件，用来包括自定义的模板库中需要使用到的
所有类类型，然后在模板定义头文件中include。

myTemplate.h		//模板定义
myTemplateHead.h	//myTemplate.h中需要使用到的所有类的前置声明

#8 ======================================================================================================

模板的错误，很多都是在链接时才会报错，这由编译器处理模板的机制决定的。

#9 ======================================================================================================

类模板：

类模板和函数模板相似，都是通过定义一个模板参数，并在后续的代码中使用在这个参数，接着把实例化成具体类类型
的任务交给编译器来完成。比如：


template<typename T1,typename T2>
class A{

public:
	A(){
	
	}
	~A();
	void func(T1,T2);
}

使用时： A<int,float> a1;

#10 ======================================================================================================

使用同一个模板实例化出来的类，他们之间没有任何关系，都是作为独立的类类型存在。他们之间也没有任何互相访问
的特权，是完全独立的

#11 ======================================================================================================

模板类 的 声明和函数实现分离。

类通常都是由  h 文件 和 cpp文件共同组成。那么成员函数在cpp文件必须在每一个函数前面都写出模板参数列表

A.h
	template<typename T>
	class A{

	   ...

	   func(T);

	   ...

	}

A.cpp

	template<typename T>
	void A::func(T){
	   ....
	}

#12 ======================================================================================================

在模板类中，编译器处理模板自身引用时不需要指定模板类型：

template<typename T>
class A{

   A& func();			//正确
  // A<T>& func();		//错误，不需要指定T

}

#13 ======================================================================================================

接 #12 ，我们在实现类时，如果返回值是模板类，那么需要指定模板参数，因为此时已经出模板类的作用域了。

template<typename T>
A<T>* A<T>::func(){		//需要指定 T，因为调用者很可能不是自己，那么调用者必须指定T的类型

   A *pa = new A<T>();		//不需要指定T，因为是在A的作用域内
   return pa;

}

#14 ======================================================================================================

如果一个模板类中有一个 “非模板“ 友元，那么这个友元类可以访问所有有这个模板类创建的类。这很好理解，因为
编译器在实例化模板那类的时候，始终用的是同一个友元类，相当于声明友元类这句代码被复制给所有的模板类的实例


也可以为模板类的特定实例指定模板，而其他模板类的实例将不使用

还有其他的配对组合，具体不赘述，使用时再查阅

#15 ======================================================================================================

模板类的static成员：模板类的 不同类实例类型 有用自己的static成员，各个模板类实例之间不会公用。

#16 ======================================================================================================

模板的默认实参列表

像正常函数一样可以有默认参数一样，模板类/函数也可以有默认参数。

（！）泛型算法中的谓词参数就是这样”具有默认实参“的模板函数。因为它的第三个参数可以使用谓词，如果不传入，那么
会使用默认动作。

例子：

	template<typename T, typename F = less<T>>		//这里把一个函数声明为一个模板类型
	int compare(const T &v1,const T &v2, F f=F())		//第三个参数是一个函数，且类型是less<T>,
								//这也隐士声明最后一个参数必须是一个入参是T
								//的可调用对象
	{
		if(f(v1,v2)) return -1;
		if(f(v2,v1)) return 1;
		return 0; 
	}

	注：默认实参的的可调用对象明确指明了入参类型为T，所以compare在使用时要确保入参匹配


（！！！）类模板的默认实参和函数模板类似：都是  ”在定义模板参数时，指定默认类型“
	template<typename T=int>
	class A{
	    void func(T);
	}


#17 ======================================================================================================

除了 类模板 和 函数模板，还有类的成员函数模板，即类是正常类，只对个别函数定义为模板函数：

	class DebugDelete{			//非模板类，对delete动作包装，在delete之前输出一行日志
	
	public:
	      DebugDelete(std::ostream &s = std::cerr):os(s){  }
	      template<typename T>
	      operator()(T *p) const{				//先输出一行日志，然后删除对象
		   os<<"delete unique_ptr"<<std::endl;
		   delete p;
	      }
	private:
	      std::ostream &os;	
	}


#18 ======================================================================================================

 622 类模板的成员模板


