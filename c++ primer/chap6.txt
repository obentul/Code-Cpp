#1 ==================================================================================

函数的参数传递：

函数的参数传递分为两种情况：
1）形参是引用类型，则把形参绑定到实参上，相当于定义一个引用类型。
2）形参不是引用类型，直接传值(和c一样)。
	ps：如果使用类作为形参（不是类引用，也不是类指针），那么也会传值，使用上和普通数据
		类型一样，即便自定义的类并没有实现拷贝构造函数
		（疑问：貌似编译器会自动生成拷贝构造，在后面的章节中找答案）
		（解惑：编译器会自动生成 拷贝构造函数(赋值构造函数)）
		
#2 ==================================================================================

编译器是否会为自定义的类创建 拷贝构造函数？

问题1：
有些标准库类 和 容器不提供拷贝构造，这些类就无法使用 那些 以类作为参数的函数。
问题2：
既然可以屏蔽 类 的拷贝构造，那么说明拷贝构造函数可能是编译器自动创建的，那么如果屏蔽拷贝
构造，以保护某些类实例。


屏蔽拷贝构造的方法：
1）重写=运算符，在=运算符中什么也不做，即重写operator=()
2）重写拷贝构造函数，即重写A(A tmp);


#3 ==================================================================================

形参的初始化 和 变量的初始化 是 “一模一样的”

#4 ==================================================================================

数组作为形参

数组的两个特性，让使用数组作为参数时有些特殊：
1）数组不能赋值(c++和c一样，不能给数组批量赋值，但是结构体可以)
2）使用数组名时，实际使用的是数组首元素的地址

所以，我们在使用数组作为参数时，传递的不是数组的值，而是数组的首元素地址
	PS : 其实和c中是一样的，这里只是说明一下
	
	有明确指定成员个数的数组作为参数时，成员个数不起作用，仅仅用来告诉调用者自己
	希望获得一个多少元素的数组。
	
前面有介绍到使用 begin() 和 end() 来模拟数组的迭代器。那么我们如果真想使用数组作为
参数，可以考虑使用 begin() 和 end()作为入参，而形参就是简单的 数组指针，比如：
		void func(char *begin,char *end)
		
PS : 可以使用数组的引用来模拟“使用的是数组，而不是指针”。

PPS :  考虑到数组的特殊性，还是建议使用c的处理方式，不要使用引用，就是当做指针来处理。

#5 ==================================================================================

可变参数函数：

1）使用initializer_list<T>作为形参
	这种方法，要求可变参数的类型一致，initializer_list<T>和vector<T>类似，只不过initializer_list里
	的值只能是常量，不可在函数中修改
		例：
			void func(initializer_list<int> il);		//在函数实现中，il的使用和vector一样
			
			func({1,2,3,4,5});

2）可变参数模板函数，在后续讨论

3）省略号(和c一样)，不推荐在c++中使用，因为很多类在进入省略号列表中，无法完整正确的拷贝，即传
	值有问题。
		（这里需要自己写一个printf）
		
#6 ==================================================================================

可以return 列表，但是要求函数返回值类型能够接受 {} 赋值，这就相当于创建个临时容器变量，然后
传值出去，但是要求容器能够进行赋值操作，比如数组就不行。

	例：
		vector<int> func(){
			...
			
			return {1,2,3};
		}
	
#7 ==================================================================================

6.3.3









