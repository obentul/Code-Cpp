#1 ==================================================================================

函数的参数传递：

函数的参数传递分为两种情况：
1）形参是引用类型，则把形参绑定到实参上，相当于定义一个引用类型。
2）形参不是引用类型，直接传值(和c一样)。
	ps：如果使用类作为形参（不是类引用，也不是类指针），那么也会传值，使用上和普通数据
		类型一样，即便自定义的类并没有实现拷贝构造函数
		（疑问：貌似编译器会自动生成拷贝构造，在后面的章节中找答案）
		（解惑：编译器会自动生成 拷贝构造函数(赋值构造函数)）
		
#2 ==================================================================================

编译器是否会为自定义的类创建 拷贝构造函数？

问题1：
有些标准库类 和 容器不提供拷贝构造，这些类就无法使用 那些 以类作为参数的函数。
问题2：
既然可以屏蔽 类 的拷贝构造，那么说明拷贝构造函数可能是编译器自动创建的，那么如果屏蔽拷贝
构造，以保护某些类实例。


屏蔽拷贝构造的方法：
1）重写=运算符，在=运算符中什么也不做，即重写operator=()
2）重写拷贝构造函数，即重写A(A tmp);


#3 ==================================================================================

形参的初始化 和 变量的初始化 是 “一模一样的”

#4 ==================================================================================

数组作为形参

数组的两个特性，让使用数组作为参数时有些特殊：
1）数组不能赋值(c++和c一样，不能给数组批量赋值，但是结构体可以)
2）使用数组名时，实际使用的是数组首元素的地址

所以，我们在使用数组作为参数时，传递的不是数组的值，而是数组的首元素地址
	PS : 其实和c中是一样的，这里只是说明一下
	
	有明确指定成员个数的数组作为参数时，成员个数不起作用，仅仅用来告诉调用者自己
	希望获得一个多少元素的数组。
	
前面有介绍到使用 begin() 和 end() 来模拟数组的迭代器。那么我们如果真想使用数组作为
参数，可以考虑使用 begin() 和 end()作为入参，而形参就是简单的 数组指针，比如：
		void func(char *begin,char *end)
		
PS : 可以使用数组的引用来模拟“使用的是数组，而不是指针”。

PPS :  考虑到数组的特殊性，还是建议使用c的处理方式，不要使用引用，就是当做指针来处理。

#5 ==================================================================================

可变参数函数：

1）使用initializer_list<T>作为形参
	这种方法，要求可变参数的类型一致，initializer_list<T>和vector<T>类似，只不过initializer_list里
	的值只能是常量，不可在函数中修改
		例：
			void func(initializer_list<int> il);		//在函数实现中，il的使用和vector一样
			
			func({1,2,3,4,5});

2）可变参数模板函数，在后续讨论

3）省略号(和c一样)，不推荐在c++中使用，因为很多类在进入省略号列表中，无法完整正确的拷贝，即传
	值有问题。
		（这里需要自己写一个printf）
		
#6 ==================================================================================

可以return 列表，但是要求函数返回值类型能够接受 {} 赋值，这就相当于创建个临时容器变量，然后
传值出去，但是要求容器能够进行赋值操作，比如数组就不行。

	例：
		vector<int> func(){
			...
			
			return {1,2,3};
		}
	
#7 ==================================================================================

#1  ====================================================================================
函数重载

main函数不能重载

顶层const无法用来区分函数的参数列表

#2  ====================================================================================

函数的有点在于，能够将修改点集中起来。但是缺点就是，进入函数需要有一定的上下文切换开销。

内联函数可以解决普通函数的调用跳转问题，内联函数可以堪称是宏，函数在编译时，会自动展开。
内联函数和宏有相同的属性，那么弊端也是明显的，那就是会增加输出文件的大小。所以内联函数一般
用在对速度要求比较高，且函数代码量不大的地方。

inline void func()

constexpr函数

内联函数 和 constexpr函数 和其他函数不一样。这两个函数可以多次定义，且编译器允许。
这两个函数具有文件作用域，而不会像普通函数那样出现符号表冲突。

因此，这两个函数一般在申明时就定义了，且一般放在头文件中（和宏的使用一样，都是放在头文件中）

#3  ====================================================================================

assert的使用
assert是在 “预处理阶段” 展开的一个宏，它定义在cassert头文件中，由于是预处理阶段展开，
所以不需要编译器参与，故也不存在名称空间，所以不需要使用类似 std::assert 

assert会对其括号内的表达式求值，如果结果是0，则会输出错误信息，同时终止函数的执行。

assert(xxx)  等同于  if(xxx) { LOG(INFO)<<"发生错误"; exit -1;}

#4  ====================================================================================

gcc -D NDEBUG 等同于在 main.c 文件的一开是 #define NDEBUG

#5  ====================================================================================

编译器内置了一些宏，比如下面：

__FILE__		当前文件名
__LINE__		当前所在行号
__TIME__		当前时间
__DATE__		当前日期


#6  ====================================================================================
 
函数指针

函数指针指向某 “一类” 函数，而这个 “类” 的区分，以  “返回值” 和 “参数列表” 为辨别条件。而与
“函数名” 无关

void func1(int,int);		//函数1
void func2(int,int);	//函数2

void (*pfunc)(int,int);	//指向 void (int,int)的指针

pfunc既可以指向func1，又可以指向func2


#7  ====================================================================================
 
函数指针/函数类型 作为另一个函数的入参。

下面三个申明等价：
void func1(int arg1,int arg2,void func2(int,int));
void func1(int arg1,int arg2,void (int,int));
void func1(int arg1,int arg2,void (*pfunc)(int,int));

func1接收3个参数，第三个是一个 void (int,int)类型的函数，或者说函数指针。

我们在传递的时候，可以传函数名，也可以传函数地址

ps：我们在使用的时候，直接将函数名传递进去即可，编译器会自动转换成函数地址。


#8  ====================================================================================

我们可以使用typedef 和 decltype 来让函数指针的定义更加简单

typedef void func(int,int);			//定义一个函数类型func，等价于void (int,int)类型的函数
typedef void (*pfunc)(int,int);		//定义一个函数指针类型pfunc，等价于void (int,int)类型的函数指针
func *pf_1;
pfunc pf_2;


void func2(int,int);				//申明一个函数，这个函数已经在别的地方实现
typedef decltype(func2) func3;		//定义一个函数类型func3，这个函数类型和func2的函数类型一样
typedef decltype(func2) *pfunc3;	//定义一个函数指针类型pfunc3，等价与func2函数类型的函数指针

func3 *pf_3;						//定义一个函数指针pf_3，这个函数指针指向func3函数那样的函数
pfunc3 pf_4;				

#9  ====================================================================================

函数的返回值可以是函数指针。

注意：这里和函数作为入参不同，作为入参时，可以时函数指针，也可以时函数原型，但是在作为返回值
	  时，必须时函数指针。
	  


























