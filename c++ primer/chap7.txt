#1 ==================================================================================

函数的成员函数，可以在类内部实现，也可以在类外部实现，在类内部实现的函数默认是inline的，
即便没有显式地进行inline声明

#2 ==================================================================================

编译器在处理类时分两步执行：首先编译成员声明，然后编译实现。

所以，如果成员函数的实现放在了成员函数/成员变量 的前面，也不会导致编译失败。

#3 ==================================================================================

构造函数不能是const的

#4 ==================================================================================

如果类没有显式地定义“任何一个”构造函数，那么编译器会为我们隐式地定义一个默认构造函数，
即合成的默认构造函数。

 编译器生成的默认构造函数，就是空参数的，  A();
 
 （！）默认构造函数 === 无参数的构造函数

 PS：所有由编译器创建的构造函数，都叫做“合成的构造函数”，比如合成的默认构造函数，合成
	 的拷贝构造函数。
	 
	默认构造函数有如下动作：1）如果存在初始值(成员函数定义时就给值)，则使用初始值初始化成员
							2）没有初始值的成员都被给默认值。
							
 （！）再次强调，“当且仅当”没有定义“任何”构造函数时，编译器才会自动生成默认构造函数
 
#5 ==================================================================================

合成的默认构造函数只适用于普通类。一般情况下，我们还是要自己定义构造函数，原因如下：
1）编译器 “仅仅” 在我们没定义 “任何” 构造函数的情况下，才会为我们生成默认构造函数，
   “如果我们定义了一个非空参数的构造函数，那么编译器就不会为我们生成默认构造函数”,
   那么我们的类就缺失了无参数的构造函数(默认构造函数)
2）合成的默认构造函数是空的，不接受参数，也不给成员变量显式初始化的，这就意味着像数组
   和指针这样的成员变量将不会被正确的初始化。因为编译器不会初始化这种 “复合类型” 。
   那么在使用类的指针成员变量时，就可能访问到位置区域，或者coredump
3）如果某些类中使用了别的类(这里一般指自定义的)作为成员变量，而这个“别的类”又没有默认
   构造函数(可以有其他构造函数，但是没有空参列表的默认构造函数)，那么编译器是无法自发地
   去使用别的构造函数，或者自发地创建一个默认构造函数(因为这个别的类已经定义过了，且
   通过定义一个构造函数来告知编译器，我不许要你为我创建默认构造函数)。这就会导致编译
   失败。
		ps：一般情况下，定义一个类以后，最好把默认构造函数定义出来。
		
#6 ==================================================================================
   
编译器会为没有初始化的成员变量初始化，给一个初始值。列表初始化可以使全量的，也可以只有
个别成员变量，未被显式初始化的成员将会获得默认初始值。

#7 ==================================================================================

除了初始化之外，类还需要控制拷贝、赋值 和 销毁对象时的行为。

拷贝：传值方式传递类，比如函数参数是类(不是类指针，也不是类引用)，这个时候就会进行类拷贝。

赋值：当使用赋值运算符给类(不是指针，也不是引用)进行赋值时。

销毁：显式销毁，比如delete一个类指针，这会释放指针指向的类。再比如定义一个局部类实例，当
      代码运行出 {} 时，局部变量被释放，这是也会调用析构来销毁类
	  
（！）如果我们不明确定义 拷贝，赋值，销毁 这三个动作，那么编译器将会自动为我们创建。

myclass B();
myclass A = B;	//触发赋值	,	这里等于先使用默认构造，在使用operator=进行赋值
myclass A(B);	//触发拷贝	,	对应的构造函数为 A(myclass B);

	（！）小结：我们只要知道，对类进行 赋值(=) , 拷贝(函数传参) , 销毁(从内存中擦除)这
			    三个动作，编译器已经为我们安排好了即可。
				如果需要，我们可以重写。
				
#8 ==================================================================================
	
访问控制与封装

使用struct 和 class定义类的区别：
struct对于未指明访问权限的内容，给予默认public的权限控制。
class对于未指明访问权限的内容，给予默认private的权限控制。
    ps：某些时候在第一个private/public出现之前，可能就会有一些成员函数/变量。
		
除了上述不同外，struct和class是一样的。但是为了养成好习惯，还是要明确指定每一个成员的
访问权限。

#9 ==================================================================================

友元 ： 让友元对象能够访问自己的private成员

友元分为：友元函数 和 友元类

友元函数，让指定的函数能够访问自己的private成员，而友元函数通常是定义在类外部但是又实现
在类文件(.h / .cpp)中的函数。或者也可以是其他类的public函数。

	A.h

	class A{
		friend void func();		//友元函数
	
		private:
			int m_i;
	}

	//定义在类文件中，但是在类外，这个函数也可以放在cpp中，都一样，只要能访问到相应类即可
	void func(A &a){
		...
		a.m_i++;		//友元函数可以访问private成员
						//在这里通过引用，可以 读/写 类A的private成员变量
	}
	

友元类，让某个类可以访问自己的private成员

一般情况下，在类的开始位置集中声明友元函数/友元类。友元不受类的访问权限控制。
（！）回顾上面说的struct默认public 和 class默认private，这里友元不受这个控制，不要搞混淆

#10 ==================================================================================

封装的好处：

1）类作为一个实体，具有两个特性，服务能力 和 状态记录。如果不进行封装，那么请求服务的
	“使用者”就可以随意修改 服务者的状态，这样就会让别人在请求服务器得不到正确的服务。
2）封装既是对 服务者的保护， 也是对使用者的保护，让使用者面对接口编程，这样的代码分层
	更清晰，迭代更安全
	
	
#11 ==================================================================================
	
前面提到了如何让 友元函数 自由访问某个类，那么如何在类中使用友元函数呢？

friend void func();	这只是一个权限说明，“并不是函数声明”，所以无法通过这条语句就让类
能够访问友元函数。

我们需要在类的定义之前对友元函数进行一次声明，比如：


	A.h

	void func(A &a);			//声明友元函数，让A可以访问友元函数
	
	class A{
		friend void func();		//说明友元函数可以自由访问A，并不是声明
	
		private:
			int m_i;
	}

	//定义在类文件中，但是在类外，这个函数也可以放在cpp中，都一样，只要能访问到相应类即可
	void func(A &a){
		...
		a.m_i++;		//友元函数可以访问private成员
						//在这里通过引用，可以 读/写 类A的private成员变量
	}
	

	小结：至此，友元<===>类 双向访问通道已经打通。
	
#12 ==================================================================================


为类定义属于自己的独有类型。

class A{
public:										//新定义的类型，可以被外部访问，private则表示只能自己使用
	typedef std::string::size_type pos;		//定义一个pos类型，其原始类型是string::size_type
	using pos_1 = std::string::size_type;	//同上
	
public:
	pos 	m_a;		//使用
	pos_1 	m_b;
	
}

类内类型的定义，需要放在类的最开头，相当于做了类型声明，因为新类型不是类的成员(函数/变量)，所以
不享受编译器优先处理成员的红利，故需要做前置声明。

#13 ==================================================================================

再谈默认构造函数

默认构造函数是指，参数列表为空的构造函数，不论是否有具体实现。
如果在h文件中声明了默认构造函数，则要么在h/cpp中实现，要么在声明的地方使用=default来让
编译器代理生成一个空的默认构造函数。

//1
A.h
class A{
	public:
		A(){
			...		//有内容的默认构造
		}
}

//2
A.h
class A{
	public:
		A();			//先声明
}
A.cpp
A::A(){
	...					//自己生成有内容的构造函数
}
OR
A::(){}					//自己生成空内容的构造函数

//3
A.h
class A{
	public:
		A()=default;	//让编译器代为生成空内容的构造函数，不需要自己在cpp中实现
}

#14 ==================================================================================

mutable关键字 ：用来对抗const成员函数

我们在定义某些成员函数时，会使用const修饰，以表示当前成员函数不会修改成员变量，比如：
class A{
	public:
		void printfonly()const;
		
	private:
		
}
但是，如果我们有一些需要修改的成员变量，那么怎么办？又想保证其他成员变量不被修改，又想
能修改某些特殊成员变量。这个时候就可以用mutable来修饰那些需要特殊对待的。


#15 ==================================================================================

成员变量的初始化：
1）等号赋值   string m_s = "init string";
2）初始化列表   string m_s{"init string"};

  基本类型只能使用 1） ，类可以使用 1）或 2） ， 复合类只能使用 2）
  int					 string					 vector / map /...
  
#16 ==================================================================================

7.3.2















