#1 ==================================================================================

函数的成员函数，可以在类内部实现，也可以在类外部实现，在类内部实现的函数默认是inline的，
即便没有显式地进行inline声明

#2 ==================================================================================

编译器在处理类时分两步执行：首先编译成员声明，然后编译实现。

所以，如果成员函数的实现放在了成员函数/成员变量 的前面，也不会导致编译失败。

#3 ==================================================================================

构造函数不能是const的

#4 ==================================================================================

如果类没有显式地定义“任何一个”构造函数，那么编译器会为我们隐式地定义一个默认构造函数，
即合成的默认构造函数。

 编译器生成的默认构造函数，就是空参数的，  A();
 
 （！）默认构造函数 === 无参数的构造函数

 PS：所有由编译器创建的构造函数，都叫做“合成的构造函数”，比如合成的默认构造函数，合成
	 的拷贝构造函数。
	 
	默认构造函数有如下动作：1）如果存在初始值(成员函数定义时就给值)，则使用初始值初始化成员
							2）没有初始值的成员都被给默认值。
							
 （！）再次强调，“当且仅当”没有定义“任何”构造函数时，编译器才会自动生成默认构造函数
 
#5 ==================================================================================

合成的默认构造函数只适用于普通类。一般情况下，我们还是要自己定义构造函数，原因如下：
1）编译器 “仅仅” 在我们没定义 “任何” 构造函数的情况下，才会为我们生成默认构造函数，
   “如果我们定义了一个非空参数的构造函数，那么编译器就不会为我们生成默认构造函数”,
   那么我们的类就缺失了无参数的构造函数(默认构造函数)
2）合成的默认构造函数是空的，不接受参数，也不给成员变量显式初始化的，这就意味着像数组
   和指针这样的成员变量将不会被正确的初始化。因为编译器不会初始化这种 “复合类型” 。
   那么在使用类的指针成员变量时，就可能访问到位置区域，或者coredump
3）如果某些类中使用了别的类(这里一般指自定义的)作为成员变量，而这个“别的类”又没有默认
   构造函数(可以有其他构造函数，但是没有空参列表的默认构造函数)，那么编译器是无法自发地
   去使用别的构造函数，或者自发地创建一个默认构造函数(因为这个别的类已经定义过了，且
   通过定义一个构造函数来告知编译器，我不许要你为我创建默认构造函数)。这就会导致编译
   失败。
		ps：一般情况下，定义一个类以后，最好把默认构造函数定义出来。
		
#6 ==================================================================================
   
编译器会为没有初始化的成员变量初始化，给一个初始值。列表初始化可以使全量的，也可以只有
个别成员变量，未被显式初始化的成员将会获得默认初始值。

#7 ==================================================================================

除了初始化之外，类还需要控制拷贝、赋值 和 销毁对象时的行为。

拷贝：传值方式传递类，比如函数参数是类(不是类指针，也不是类引用)，这个时候就会进行类拷贝。

赋值：当使用赋值运算符给类(不是指针，也不是引用)进行赋值时。

销毁：显式销毁，比如delete一个类指针，这会释放指针指向的类。再比如定义一个局部类实例，当
      代码运行出 {} 时，局部变量被释放，这是也会调用析构来销毁类
	  
（！）如果我们不明确定义 拷贝，赋值，销毁 这三个动作，那么编译器将会自动为我们创建。

myclass B();
myclass A = B;	//触发赋值	,	这里等于先使用默认构造，在使用operator=进行赋值
myclass A(B);	//触发拷贝	,	对应的构造函数为 A(myclass B);

	（！）小结：我们只要知道，对类进行 赋值(=) , 拷贝(函数传参) , 销毁(从内存中擦除)这
			    三个动作，编译器已经为我们安排好了即可。
				如果需要，我们可以重写。
				
#8 ==================================================================================
	
访问控制与封装

使用struct 和 class定义类的区别：
struct对于未指明访问权限的内容，给予默认public的权限控制。
class对于未指明访问权限的内容，给予默认private的权限控制。
    ps：某些时候在第一个private/public出现之前，可能就会有一些成员函数/变量。
		
除了上述不同外，struct和class是一样的。但是为了养成好习惯，还是要明确指定每一个成员的
访问权限。

#9 ==================================================================================

友元 ： 让友元对象能够访问自己的private成员

友元分为：友元函数 和 友元类

友元函数，让指定的函数能够访问自己的private成员，而友元函数通常是定义在类外部但是又实现
在类文件(.h / .cpp)中的函数。或者也可以是其他类的public函数。

	A.h

	class A{
		friend void func();		//友元函数
	
		private:
			int m_i;
	}

	//定义在类文件中，但是在类外，这个函数也可以放在cpp中，都一样，只要能访问到相应类即可
	void func(A &a){
		...
		a.m_i++;		//友元函数可以访问private成员
						//在这里通过引用，可以 读/写 类A的private成员变量
	}
	

友元类，让某个类可以访问自己的private成员

一般情况下，在类的开始位置集中声明友元函数/友元类。友元不受类的访问权限控制。
（！）回顾上面说的struct默认public 和 class默认private，这里友元不受这个控制，不要搞混淆

#10 ==================================================================================

封装的好处：

1）类作为一个实体，具有两个特性，服务能力 和 状态记录。如果不进行封装，那么请求服务的
	“使用者”就可以随意修改 服务者的状态，这样就会让别人在请求服务器得不到正确的服务。
2）封装既是对 服务者的保护， 也是对使用者的保护，让使用者面对接口编程，这样的代码分层
	更清晰，迭代更安全
	
	
#11 ==================================================================================
	
前面提到了如何让 友元函数 自由访问某个类，那么如何在类中使用友元函数呢？

friend void func();	这只是一个权限说明，“并不是函数声明”，所以无法通过这条语句就让类
能够访问友元函数。

我们需要在类的定义之前对友元函数进行一次声明，比如：


	A.h

	void func(A &a);			//声明友元函数，让A可以访问友元函数
	
	class A{
		friend void func();		//说明友元函数可以自由访问A，并不是声明
	
		private:
			int m_i;
	}

	//定义在类文件中，但是在类外，这个函数也可以放在cpp中，都一样，只要能访问到相应类即可
	void func(A &a){
		...
		a.m_i++;		//友元函数可以访问private成员
						//在这里通过引用，可以 读/写 类A的private成员变量
	}
	

	小结：至此，友元<===>类 双向访问通道已经打通。
	
#12 ==================================================================================


为类定义属于自己的独有类型。

class A{
public:										//新定义的类型，可以被外部访问，private则表示只能自己使用
	typedef std::string::size_type pos;		//定义一个pos类型，其原始类型是string::size_type
	using pos_1 = std::string::size_type;	//同上
	
public:
	pos 	m_a;		//使用
	pos_1 	m_b;
	
}

类内类型的定义，需要放在类的最开头，相当于做了类型声明，因为新类型不是类的成员(函数/变量)，所以
不享受编译器优先处理成员的红利，故需要做前置声明。

#13 ==================================================================================

再谈默认构造函数

默认构造函数是指，参数列表为空的构造函数，不论是否有具体实现。
如果在h文件中声明了默认构造函数，则要么在h/cpp中实现，要么在声明的地方使用=default来让
编译器代理生成一个空的默认构造函数。

//1
A.h
class A{
	public:
		A(){
			...		//有内容的默认构造
		}
}

//2
A.h
class A{
	public:
		A();			//先声明
}
A.cpp
A::A(){
	...					//自己生成有内容的构造函数
}
OR
A::(){}					//自己生成空内容的构造函数

//3
A.h
class A{
	public:
		A()=default;	//让编译器代为生成空内容的构造函数，不需要自己在cpp中实现
}

#14 ==================================================================================

mutable关键字 ：用来对抗const成员函数

我们在定义某些成员函数时，会使用const修饰，以表示当前成员函数不会修改成员变量，比如：
class A{
	public:
		void printfonly()const;
		
	private:
		
}
但是，如果我们有一些需要修改的成员变量，那么怎么办？又想保证其他成员变量不被修改，又想
能修改某些特殊成员变量。这个时候就可以用mutable来修饰那些需要特殊对待的。


#15 ==================================================================================

成员变量的初始化：
1）等号赋值   string m_s = "init string";
2）初始化列表   string m_s{"init string"};

  基本类型只能使用 1） ，类可以使用 1）或 2） ， 复合类只能使用 2）
  int					 string					 vector / map /...
  
#16 ==================================================================================

非常量成员函数无法操作常量成员变量。
非常量成员函数的潜在台词是，当前成员函数可以修改成员变量，而这个权限明显与常量成员变量
的潜台词有冲突。

常量成员函数可以重载：

void func();			
void func()const;

在一个类中定义上述两个成员函数，编译不报错，也能是合法的。

那么问题来了，既然不能通过参数列表来区分使用哪个重载函数，那么通过什么方法来区分？
答案是，通过调用者是不是const来进行区分。
比如： 

const class A a1 = A();
class A a2 = A();

那么a1.func() 会调用const版本，a2则会调用非const版本。

#17 ==================================================================================

再次强调，在类内部定义的成员函数是inline的，因此如果想包装成员函数，有不希望有额外的调用
开销，那么把包装函数定义在类内部是一个比较好的选择。

#18 ==================================================================================

class A a;
A a;
都是合法的

#19 ==================================================================================

友元关系不传递，即不能通过继承 和 内聚来实现间接使用友元。

每个类维护自己的 友元类/友元函数

（！）除了指定类是友元，外部函数是友元，我们还可以指定某个类的某个成员函数是友元，语法
如下：
		class A{
			friend void B::func();		//指定B的成员函数是友元
		}
		
（？）指定成员函数是友元，那么对成员函数是public还是private有要求么？？？

#20 ==================================================================================

友元声明只是说明访问权限，不能代替普通的函数声明。

比如有一个 类外部函数，现在需要把这个函数声明为类A的友元函数，那么语法如下：

void func();			//这里需要前置声明函数，因为friend只是声明权限，没有符号声明的作用

class A{
	friend void func();			//这里只是声明权限，不是函数声明
}

void func(){		//函数声明在类后面，这样编译时就会提示函数找不到
	...
}

#21 ==================================================================================

类的作用域

每个类都有自己独立的作用域，访问作用域内的内容(自定义类内类型，成员函数，成员变量等等)需要
使用域访问运算符 "::" ，或者通过一个类实例的访问运算符 “.” 或 “->”


有这么一种场景：
如果类A 有成员函数func，返回值是类B 的自定义类型 B_TYPE，那么在实现func的时候应该这样写

//h
B::BTYPE func();

//cpp
B::B_TYPE A::func(){
	...
}

	注：类内类型也是有访问权限控制的，private或者public，如果想在别的类中使用类
	    内类型，则需要把类型声明在public后面，另外class修饰下，默认private访问权限

#22 ==================================================================================

成员函数体(cpp中的部分)，会在整个类被编译器处理完后才会进入编译器处理。


如果在类外部(同一个文件/不同文件但是有include关系)定义了一个typedef类型，那么在类内部
再使用typedef定义类型，则是错误的，说有时候编译器不会报错。但是我们要避免这个问题。


例如：

A.h

typedef A_TYPE int;

class{
   typedef A_TYPE int;		//错误：对A_TYPE符号再次定义
   using A_TYPE double;		//错误：对A_TYPE符号再次定义
}

	ps: 如果在别的文件中定义，则不会有影响，但是得确保这两个文件没有include关系，
	    因为，编译的单元是文件，仅仅在链接时，文件之间才能互相知道对方的符号表。

	    内层符号 覆盖 外层符号的原则，在类中不适用


如果真想定义同名 类型，那么建议放到各自的类中，定义成类内类型，不要放在类作用域之外。

#23 ==================================================================================

如果类成员函数实现中，形参的名字和成员变量的名字一样怎么办？毕竟在成员函数既能访问形参，又
能访问成员变量。

在上述场景下，会优先使用形参，适用内层覆盖外层原则，那么如果这个时候想要让外层覆盖
内层，改如何实现？

class A{

public:
    void func(int height){
        int i = height*height;			//这两个height都是形参
	int j = height*A::height;		//第一个是形参，第二个是成员变量
	int k = A::height * this->height;	//两个都是成员变量
    }

private:
    int height;

}

#24 ==================================================================================

初始值列表初始化 晚于 默认初始化，即如果初始化列表没有对所有成员进行初始化，那么没有
在列表中的成员将会获得默认初始化，而这个初始化会在其他列表成员初始化之前被执行。



一般情况下，对于类实例，我们都使用初始化，而不是使用先默认初始化在赋值，原因：
1）某些成员要求必须在定义时就有值，比如const 和 引用。
!!!2）某些成员是没有默认构造函数的类，当类有自定义的构造函数时，且没有告知编译器自己生成
   一个默认构造函数，那么这个类是没有默认构造函数的，这样的类无法使用默认构造函数，而
   没有给任何初始值的成员变量(类类型)必须要求进行默认构造，这个时候就会出现问题。

	ps：如果在成员列表中初始化，则会使用复制构造函数，而 复制构造函数 和 赋值
            构造函数，是编译器一定会为类默认创建的，所以一定会构造成功。

3）初始化的效率要优于“先默认构造，在赋值”


回忆：
编译器会为自定义类隐式创建的构造函数有：
1）合成的默认构造函数，在用户没有定义任何构造函数的情况下，由编译器代为生成，如果定义了
   任何一个非默认构造函数，则编译器不会再为我们创建合成的默认构造函数，此时如果需要使用
   默认构造函数，那么有两种方法：一是自己定义默认构造函数，实现部分按自己需要来（只要保
   证入参是空的就好）；而是使用=default告知编译器，让编译器来代为实现。
2）复制构造函数，只要用户自己不重载，编译器便会自动生成，原型为 A(A)
3）赋值构造函数，这个是对=运算符的重载，如果用户自己不重载=运算符，那么编译器会为我们
   实现=运算符，且内部逻辑是赋值所有成员变量，原型为 operator=()


小结：为了避免错误，务必使用构造来初始化类。


#25 ==================================================================================

（！）如果一个构造函数的所有参数都有默认值，那么这个构造函数对于编译器来说也是默认构造函数。

即便如此，还是不建议使用使用这个特性，还是要明确自定义默认构造函数

#26 ==================================================================================

委托构造函数的语法：

A(int i,double d,string s){
  ....
}

A():A(1,1.0,"xxx"){
  ...
}

A(string s):A(1,1.9,s){
  ...
}

默认构造函数 A() 和 构造函数 A(string s)都把构造流程委托给 构造函数 A(int,double,string),
这个时候，被委托人先执行，同时会使用委托人的参数，之后委托人执行。

#25 ==================================================================================

再次赘述：如果某个类的成员变量中有另一个类，那么务必保证另一个类有默认构造函数，否则编译器
          无法为当前类创建合成的默认构造函数。


#26 ==================================================================================

使用构造函数

前面已经用到了构造函数，不过大部分是使用的是“先构造再赋值的语法”

默认构造函数： A a;			//没有()，默认构造函数
其他构造函数： A a(10);			//有()，构造函数为 A(int)
错误，声明了一个函数：	A a();		//声明了一个A返回值，无参数的函数c


#27 ==================================================================================

构造函数的隐式转换：

A(string)

A a("1234");  //把字符数组隐式转换成string，然后再调用A(string)构造

（！）1）隐式转换只能用在单参数的构造函数
      2）隐士转换只能转一层

如果想屏蔽隐式转换，那么就把构造函数声明为explict的。这样当构造的传参类型不对时，就不会
尝试进行隐式转换。


为什么要屏蔽隐式转换，隐式转换的弊端是什么？

（！）就目前所知的，隐式转换会默认生成临时类实例，然后进行一次复制构造/赋值构造(具体看语法)。
（！）这样不是调用给定的构造函数了，这样做：
（！）一是违背了初衷
（！）二是会带来意料之外的内存消耗(临时实例)。


为了屏蔽隐式转换，可以在单参数构造函数(只有在单参数场景下才会存在隐式转换)的开头用explict修饰



（！）注意：如果使用explict修饰单参数构造函数，那么这个构造函数在使用时就必须使用初始化语法，而
	    不能使用赋值语法进行构造。
		    class{
			 explict A(int a);
		    }

		    A a(10);		//正确
		    A a = 10;		//错误，这里从10到临时实例A tmp(10),这个过程就是隐式转换
		    A a = A(10);	//正确，这样是没问题的，没有进行隐式转换。而是先构造一个
						临时实例，在使用赋值构造进行a的构造。


---------------------------
class D{
public:
	//D()=default;			//语句 1
	explicit D(int i);
};

	D d;			//编译报错：因为有一个构造函数了，所以编译器不会生成默认构造，
					    如果想使用，则放开 语句 1
	D d1(10);		//正确		
	D d2 = 10;		//编译报错
	D d3 = D(10);		//正确
----------------------------


#28 ==================================================================================

为转换显式地使用构造函数


class A{
public:
	explicit A(B b){
		...
	}
}

class B{
public:
	B(string s){
		m_s = s;
	}
private:
	string m_s;
}


上面B有一个单参数构造函数，接受一个string参数，而A也有一个单参数构造函数，是explict的，明确
表明自己不接受隐式转换，因此：

	A a("123");		//错误：试图使用B的单参数构造完成隐士转换
	A a(B("123"));		//正确：显式转换后，把临时变量给A，使用A的单参数构造


（！）我们也可以为单参数构造函数指定代理构造函数，进而实现一个跳转。

（？？？）前面说了使用=default告知编译器生成合成的默认构造函数，进而我们可以访问合成的
	 默认构造函数，那么如果想要合成的赋值构造函数呢？还有合成的复制(拷贝)构造函数呢？？


#29 ==================================================================================

2、 类与默认函数
在讲解关键字 default和delete 之前，先对类和类的默认函数作下描述与说明，从而加深对这两个关键字的理解与认知。既要知其然，也要知其所以然。C++中，当我们设计与编写一个类时，若不显著写明，则类会默认为我们提供如下几个函数：
（1）构造函数
（2）析构函数
（3）拷贝构造函数
（4）拷贝赋值函数（operator=）
（5）移动构造函数

以及全局的默认操作符函数
（1）operator,
（2）operator &
（3）operator &&
（4）operator *
（5）operator->
（6）operator->*
(7)operator new
(8)operator delete
 ———————————————— 


#30 ==================================================================================

静态成员变量的定义一般放在cpp文件中。

静态成员函数中不能使用this指针

静态成员，存在于内存静态区，在类实例化之前就已经存在于内存中，因此和实例相关的操作都不能
用在静态成员上，比如this

静态成员不属于任何实例，所以静态成员变量的初始化不能再类内做，要在类语句块外部做

































