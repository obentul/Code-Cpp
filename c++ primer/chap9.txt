




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
（！！！）
泛型算法是一套标准库，下面讨论的谓词策略是对这个标准库的补充，不是灵活的，而是在特定框架下的优化。
比如有些泛型算法只接受一元谓词，那么我们就不能传两个参数的可调用对象给他作为谓词。

所以，再次说明，下面讨论的不是通用使用方法，而是“针对”泛型算法的“补充优化方法”。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





#1  ==========================================================================================================

泛型算法本身不会操作容器，他们只是操作迭代器。又因为迭代器无法对容器进行增删动作，所以泛型算法只可能改变
容器内某个位置的值，不可能调整容器大小。

#2  ==========================================================================================================

容器的泛型算法，是指一套函数，接收“容器的迭代器”作为参数，能够修改容器中的内容，但是不能增删容器。

#3  ==========================================================================================================

如果对象/表达式 e，可以使用 e(args)，则我们认为 e 是 “可调用的，callable”，其中args是一个由逗号分隔的参数列表


目前为止，有：
1）函数指针
2）函数
3）重载了调用运算符[即operator()]
4）lambda表达式，
上述四种方式可以实现 “可调用的对象 或 表达式”。



#4  ==========================================================================================================

（！）谓词

谓词是一个表达式，它作为泛型算法的第三个参数出现。

（!）为什么需要使用谓词？？？
很多泛型算法都会比较输入序列中的元素，默认情况下，“这类算法使用容器元素的 < 和 == 的重载动作 进行比较过程”，
但是很多时候，这些动作不满足使用场景。这个时候，就需要提供一手段，“在不再次重载 < 和 == 的前提下”，可以让
泛型算法执行另外一个动作，而不是默认的 < 和 == 动作。stl设计者在设计模板的时候考虑到了这点，因此，他们留下
第三个参数让用户自定义。这就是谓词。


（！）小结：我们可以通过把“可调用对象”（见#3）传递给泛型算法的第三个参数，作为谓词，以此来让泛型算法在
进行比较的时候不再使用< 和 == 。

ps：如果泛型算法内部实现有使用 容器元素的 < 和 == 重载版本，那么会被自动替换成谓词。如果没有，则不生效。


上述表述中，谓词会作用在容器元素上，那么这就要求容器元素的类型能够和谓词的参数相匹配。或者能够互相转换


（！）谓词有两种：一元 和 二元，一元意味着谓词只接收一个参数，二元即两个参数。那么最多只能有两个参数？？？
目前是这样的，算法值接收一元/二元谓词。但是我们可以通过使用lambda表达式来绕过这个限制，见#5


（！）不同的泛型算法可以接受不同的谓词，有的只能接收一元，有的只能接收二元，有点一元和二元会有不同的动作

例子：
	//可调用对象isShorter

	bool isShorter(const string& s1,const string& s2){
		return s1.size()<s2.size();
	}

	//泛型算法使用 isShorter作为谓词，以此来代替 string的 < 和 ==
	sort(words.begin(),words.end(),isShorter);

sort算法接收二元谓词，因此isShorter可以传递给sort作为 < 和 == 的替代品


#5  ==========================================================================================================

根据算法接收 一元谓词 还是 二元谓词，我们传递给算法的谓词必须严格接收一个/两个参数。我们可以使用lambda
表达式来定义一个“没有元”的可调用对象。这样就绕开了限制 。

（！）注：一元、二元 是针对 “函数” 这种 可调用对象的

#6  ==========================================================================================================

lambda表达式的格式：

[capture list](parameter list)->return type{function body}

(必选，可以为空)capture list	：希望从函数中代入表达式的参数列表，这个参数仅限函数的局部变量。
(可选)parameter list	：lambda的参数列表
(可选)return type	：lambda的返回值
(必选)function body	：lambda的函数体

例子1：
	auto f = []{ return 42;}	//定义一个lanbda表达式f
	f();				//调用lambda

例子2：
	auto f = [](const string& a,const string &b){ return a.size()<b.size();}
	f("123","1234");

	例子2中，lambda的参数列表为两个字符串，希望获得调用函数局部变量的参数列表依旧为空

使用：
	stable_sort(words.begin(),words.end(),[](const string& a,const string &b){return a.size()<b.size();});
		用lambda表达式作为谓词，告知stable_sort这个泛型算法，如果在比较两个元素时，使用lambda表达式
		，而不是使用<和==这种系统自带的重载运算符。

1





