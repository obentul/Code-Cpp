




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
（！！！）
泛型算法是一套标准库，下面讨论的谓词策略是对这个标准库的补充，不是灵活的，而是在特定框架下的优化。
比如有些泛型算法只接受一元谓词，那么我们就不能传两个参数的可调用对象给他作为谓词。

所以，再次说明，下面讨论的不是通用使用方法，而是“针对”泛型算法的“补充优化方法”。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





#1  ==========================================================================================================

泛型算法本身不会操作容器，他们只是操作迭代器。又因为迭代器无法对容器进行增删动作，所以泛型算法只可能改变
容器内某个位置的值，不可能调整容器大小。

#2  ==========================================================================================================

容器的泛型算法，是指一套函数，接收“容器的迭代器”作为参数，能够修改容器中的内容，但是不能增删容器。

#3  ==========================================================================================================

如果对象/表达式 e，可以使用 e(args)，则我们认为 e 是 “可调用的，callable”，其中args是一个由逗号分隔的参数列表


目前为止，有：
1）函数指针
2）函数
3）重载了调用运算符[即operator()]
4）lambda表达式，
上述四种方式可以实现 “可调用的对象 或 表达式”。



#4  ==========================================================================================================

（！）谓词

谓词是一个表达式，它作为泛型算法的第三个参数出现。

（!）为什么需要使用谓词？？？
很多泛型算法都会比较输入序列中的元素，默认情况下，“这类算法使用容器元素的 < 和 == 的重载动作 进行比较过程”，
但是很多时候，这些动作不满足使用场景。这个时候，就需要提供一手段，“在不再次重载 < 和 == 的前提下”，可以让
泛型算法执行另外一个动作，而不是默认的 < 和 == 动作。stl设计者在设计模板的时候考虑到了这点，因此，他们留下
第三个参数让用户自定义。这就是谓词。


（！）小结：我们可以通过把“可调用对象”（见#3）传递给泛型算法的第三个参数，作为谓词，以此来让泛型算法在
进行比较的时候不再使用< 和 == 。

ps：如果泛型算法内部实现有使用 容器元素的 < 和 == 重载版本，那么会被自动替换成谓词。如果没有，则不生效。


上述表述中，谓词会作用在容器元素上，那么这就要求容器元素的类型能够和谓词的参数相匹配。或者能够互相转换


（！）谓词有两种：一元 和 二元，一元意味着谓词只接收一个参数，二元即两个参数。那么最多只能有两个参数？？？
目前是这样的，算法值接收一元/二元谓词。但是我们可以通过使用lambda表达式来绕过这个限制，见#5


（！）不同的泛型算法可以接受不同的谓词，有的只能接收一元，有的只能接收二元，有点一元和二元会有不同的动作

例子：
	//可调用对象isShorter

	bool isShorter(const string& s1,const string& s2){
		return s1.size()<s2.size();
	}

	//泛型算法使用 isShorter作为谓词，以此来代替 string的 < 和 ==
	sort(words.begin(),words.end(),isShorter);

sort算法接收二元谓词，因此isShorter可以传递给sort作为 < 和 == 的替代品


#5  ==========================================================================================================

根据算法接收 一元谓词 还是 二元谓词，我们传递给算法的谓词必须严格接收一个/两个参数。我们可以使用lambda
表达式来定义一个“没有元”的可调用对象。这样就绕开了限制 。

（！）注：一元、二元 是针对 “函数” 这种 可调用对象的

#6  ==========================================================================================================

lambda表达式的格式：

[capture list](parameter list)->return type{function body}

(必选，可以为空)capture list	：希望从函数中代入表达式的参数列表，这个参数仅限函数的局部变量。
(可选)parameter list	：lambda的参数列表
(可选)return type	：lambda的返回值
(必选)function body	：lambda的函数体

例子1：
	auto f = []{ return 42;}	//定义一个lanbda表达式f
	f();				//调用lambda

例子2：
	auto f = [](const string& a,const string &b){ return a.size()<b.size();}
	f("123","1234");

	例子2中，lambda的参数列表为两个字符串，希望获得调用函数局部变量的参数列表依旧为空

使用：
	stable_sort(words.begin(),words.end(),[](const string& a,const string &b){return a.size()<b.size();});
		用lambda表达式作为谓词，告知stable_sort这个泛型算法，如果在比较两个元素时，使用lambda表达式
		，而不是使用<和==这种系统自带的重载运算符。


#7  ==========================================================================================================

（！）lambda虽然在函数作用域范围内，但是只能使用函数传递给他的局部变量，这也是  capture list  存在的原因

比如：

	sort(int sz,[sz](const string &a){ return a.size()>=sz;})

	sort把sz传递个lambda使用

如果使用不把局部变量写入capture list就在lambda中使用的话，编译时会报错



#8  ==========================================================================================================

（！）lambda的底层实现

当定义一个lambda时，编译器会生成一个未命名的类，同时将这个类实例化，这个类就是lambda的底层数据结构。另外，
capture list 会作为这个类的“成员变量”。接着会使用capture list的值来初始化各个成员变量

void func(){
  int v1 = 42;
  auto f = [v1]{return v1;}	//实例化，使用“拷贝构造”，这就意味着lambda的成员变量的初始化是使用赋值的模式
				//那么，传引用则存对照关系，传变量则存“值副本”
  f();	//输出42
}

	ps：lambda 可以使用函数的局部变量作为capture list，并不仅仅是只能使用值，还可以使用变量的引用。
	    这里引用是一个特殊，需要和求地址运算区分开来

	ps：捕获列表中可以容纳任意局部变量类型，比如指针，类，类指针，迭代器，等等。
	    这里只有引用特殊，不需要单独额外定义一个引用，直接使用&就可以。
	    


void func(int v1,[v1]{return v1})	//错误，普通函数无法接受lambda表达式作为谓词
{
  
}


void func(){
   int v1 = 42;
   auto f = [&v1]{return v1;};
   v1 = 0;
   f();		//输出0
}

上面两个例子，一个是局部变量的值捕获，一个是局部变量的引用捕获。
如果把lambda作为函数对待，那么这两种捕获方式正是函数的传值方式。所以这两种已经足够，是否会有其他方式暂不考虑。


（！）对于值捕获，使用的是传值，不必考虑原局部变量是否被释放。但对于引用捕获，就需要注意lambda在执行的时候，
      局部变量是否已经被释放，如果被释放，那么将无法访问。


#include "stdafx.h"
#include <iostream>

class A{
public:
	A()=default;
	~A(){}

public:
	int i = 10;
};

int _tmain(int argc, _TCHAR* argv[])
{
	A* pa = new A();
	auto f = [pa]{return pa->i; };
	delete pa;
	auto ret = f();
	std::cout << ret;

	getchar();
	return 0;
}

上述代码会输出随机值，因为实例已经被释放


（！！！）值捕获要求capture list内的类型能够进行拷贝动作，比如基本数据类型和具备拷贝构造函数的类。但是对于像
          一些io设备就无法进行拷贝，比如ostream对象就不能使用值捕获，只能使用引用捕获。

迭代器也可以进入捕获列表，因此需要注意迭代器是否失效。

在使用lambda的时候，尽量使用值捕获，避免是捕获指针或引用。


#9
==========================================================================================================


隐式捕获

上面说的捕获都是指定捕获列表来指定外层函数的局部变量。那么能都让lambda识别自己使用的变量是否有外层函数的局部变量
呢，答案是可以的，这就是隐式捕获。

前面提到，捕获列表中的变量有两种：
值捕获，引用捕获。一种是值传递，一种是引用传递。

那么我们在使用隐式捕获的时候，需要告诉编译器，本lambda对于隐式列表采用何种捕获方式。

（???）那么，是否默认说明了 -> 隐式捕获的捕获类表中，要么全是 “值传递”
，要么全是 “引用传递”.

 答案是否定的，我们可以在捕获列表中先指定大规则，然后对个别捕获列表指定小规则。

 例子：
	auto f = [=,&pa]{return pa->i;}

	上面的f 就是先指定值捕获 “=” ，再对pa进行引用捕获。

	auto f = [&,pa]{return pa->i;}


	(!!!)使用隐式捕获，列表的第一个值一定要是 = 或者 &
，不可将这个大范围放在后面

    ps：如果采用了 = 或 &
进行大范围限制，那么后面的小范围限制就不能再使用相同的类型。


（！！！）从隐式捕获可以看出，捕获列表的类型只有两种，要么是值捕获，要么是引用捕获。


#10
==========================================================================================================

lambda的返回值

上面使用的lambda都是没指定返回值类型的，这种场景下，要求lambda只能有一个reutrn
语句，如果大于一个，那么lambda将
忽略return的值而return void。

比如：
	//正确
	auto f = [=]{return pa->i;}	//正确返回
	//无法获取pa->i,编译错误！！！
	auto f = [=]{ 
			if(pa->i>0) return pa->i;
			else if(pa-><=0) return 0;
		    }
	//如果只有一个 return，就可以
	auto f = [=]{
			return pa->i>0?pa->i:0;
		    }
	

那么，如果确实想使用多个return分支，但是又不想或者不能通过一条语句集成怎么办，这就要使用到前面lambda表达式
范式中的指定返回值类型。

回忆下范式： 	[capture list](argument list)->return type{ function body }

可见，这里需要在 argument list 和 function body中间加入一个 ->return type
即可，

比如
	auto f = [=](const string& a,const string& b)->int { .... }


#11
==========================================================================================================

lambda的初衷是用来替代 容器泛型算法的
谓词，因此我们在使用容器泛型算法的时候，谓词尽量使用lambda，而不是使用函数。
一是因为谓词最多只能是两元的，所以在入参控制上比较麻烦，二是函数的定义是可重复利用的，而不是一次性的。

同时，在非谓词场景下，仅在函数内部的局部精简语句替代场景下使用lambda。


#12
==========================================================================================================

functional 中的 bind 函数（不是socket的bind），可以用来完成
对一个callable对象的再封装

	需要使用时在详细了解	

#13
==========================================================================================================

10.4 再探迭代器

#14
==========================================================================================================

10.5 泛型算法结构




































