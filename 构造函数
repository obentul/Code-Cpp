#1    ====================================================================================================

如何创建const实例

构造函数不能使用const修饰，故不存在使用const修饰构造函数来创建const实例这么一个说法。
如果需要一个const的实例，那么不能先用默认构造函数分配内存并给默认值再赋值！
这个时候构造函数的作用就体现出来了，可以通过调用带参数的构造函数来完成。

（！）从底层原理上来说，在构造函数执行完成前，实例都不会被放到const内存区中。可以理解为先在栈中调用构造函数
      把实例创建出来，然后把实例移动到const 内存区中。

#2    ====================================================================================================

初始化

基本数据类型，系统内置类(string,QString,QMap...)等都有默认初始化动作。即只是声明一个变量而不分配空间(使用new
来创建)，那么系统将会给其默认值，同时和局部变量一样，他们存在于栈中，随时可能被释放。

至此，基本数据类型 和 系统内置类(起始就是别人封装好的类) 在内存的分配上和 C语言的表现是一致的。可以把类就看做
是基本数据类型。

比如： int a;
       string b;
       QMap m;
这里的 a , b , m 都是没有初始值的，由系统给默认值，比如 a 的默认值就是 0，b的默认值是空字符串，m的不知道是啥，
这里来看类的表现无异于普通数据类型。

从内部原理上来说，类的默认初始化动作由一个“特殊的构造函数”来完成，这个构造函数叫“默认构造函数”，起始就是我们
平时定义的没有参数和内容的构造函数。

如果没有显式地定义构造函数(一个都没有)，那么编译器就会隐式地定义一个默认构造函数(没有内容也没有参数)。

至此，我们可以看出来，如果自定义的构造函数，既没有参数也没有实现，那么它和编译器创建的构造函数无异。

为了区分，由编译器创建的默认构造函数叫做“合成的默认构造函数”，由自己创建的默认构造函数叫做“默认构造函数”。他们
都是没参数没实现的。区别在于一个是编译器生成的，一个是自己生成的。

（！）默认构造函数/合成默认构造函数，虽然都没有内部实现，但是隐式的内部实现是对所有成员变量进行默认赋值。

再强调：如果我们自己定义了默认构造函数，那么编译器就不再创建默认构造函数，默认构造函数就是没有参数又没有
	实现的构造函数。当且仅当一个类没有任何构造函数时，编译器才会生成默认构造函数。



#3    ====================================================================================================

自定义类时，不可依赖“合成的默认构造函数”，一般都是自定义一个默认构造函数，即定义一个没参数又没实现的构造函数

原因如下：
1）合成的默认构造函数 仅 适合于简单的类，因为复杂的类多会要求初始成员变量值，使用默认构造函数无法满足
2）默认构造函数给的初始值可能会导致各种各样的未知问题，比如在栈内分配的内存，可能会出现内存踩踏等问题
3）有些时候，编译器无法生成 合成的默认构造函数 ，比如，类中的成员变量是另一个类，而这个嵌套的类又没有默认
构造函数，那么这时候就无法创建 合成的默认构造函数


总结：不要依赖于编译器创建(合成的)默认构造函数，一般都自己创建默认构造函数，毕竟，用不了几行代码


（！）编码中，只要定义了任何一个构造函数，那么就一定要把默认构造函数也一并给定义了，因为此时编译器不会再为
      我们生成 无参数无实现的 默认构造函数了。

（？）如果有其他的构造函数，又没有定义默认构造函数，会导致什么问题？？？


#4    ====================================================================================================

clasa A{

   A()=default;		//定义默认构造函数，这里的default是c11语法，表示要求编译器为当前类创建默认构造函数，
			//其实这里完成可以定义成 A() { },效果是一样的

}


#5    ====================================================================================================

如果在自定义的构造函数中，未对所有的成员变量都初始化，那么未被赋值的成员变量都会使用默认值(即和使用默认构造
函数时一样的值)

小结：这里其实也可以类比C语言，其实就是没被初始化的变量会被默认初始化。


#6    ====================================================================================================

构造初始化列表语法

class A{
   int a;
   char b;
   QString c;

}

//全部给初始值
A::A():a(0),b('c'),c("123"){

}

//部分给初始值(此时构造函数需要有参数)
A::A(n,s):a(n),b('c'),c(s){

}



记忆：构造函数名称后面增加 : , 函数体由 {} 包裹，列表写在: 和 { 之间，用逗号隔开。


#7    ====================================================================================================

(*)构造函数初始化成员列表 和 构造函数内进行成员变量赋值 的却别

包含初始化成员列表的构造函数形式如下：

A.h----
Class A{
public:
   A(int n,char m);

private:
   int a;
   char b;

}
A.cpp----

//初始化成员列表型构造函数
A::A(int n,char m):a(n),b(m){

}

//赋值型构造函数
A::A(int n,char m){
   a=n;
   b=m;
}


使用时都是 -->  A* pa = new A(1,'c');

区别在于如果成员变量中包含必须定义就赋值的成员，比如const类型 和 引用类型，那么赋值型的构造函数将产生错误，且无
论如何也没法给 const 和 引用 进行成员赋值。
此时就必须要求使用成员列表式的构造函数。

比如
class B{

  const int a;
  char &b;

}

小结：如果需要在构造时就给成员函数以初始值，那么务必使用成员列表模式的构造函数。毕竟函数原型都是一样的，只是在
cpp中实现有差异。

初始化成员列表也提高了效率，因为初始化时一个动作，赋值也是一个动作，先初始化再赋值就要做两步。但是最重要的还是上面
说的，有些成员变量类型不允许进行“先初始化再赋值”


#8    ====================================================================================================

初始化的顺序与成员变量定义的顺序有关，先定义的先初始化。和其他无关，即使是把某些变量写到了初始化列表的前端。

明确初始化顺序的原因在于，在某些场景下，某些成员变量依赖于其他变量的值，比如：

A::A(int n):a(n),b(a){ }

这里可以看到，b是依赖于a的，而不需要从构造函数的参数列表中取值，这个时候如果b先于a初始化就导致b的初始值是错误
的。
此外，如若必须，我们应该避免在初始化列表中使用成员间互相依赖的情况，尽量在构造函数的参数列表中把所有值都给全了。


#9    ====================================================================================================

委托构造函数

委托构造函数是指某些构造函数 把构造动作委托给其他构造函数，然后在其他构造函数执行完以后，在补充执行自己的构造
内容。

相当于先调用其他构造函数，然后早调用自己。

可以类比为函数调用，先调用指定函数，然后返回来再调用自己的内容


格式：

A.h
  A();	//默认构造
  A(int a)

A.cpp
  A::A(){ }  
  A::A(int a):m_a(a),A() { }

PS:如果委托方(调用者)和被委托方(被调用者)都对同一个变量进行初始化，那么依照初始化顺序决定成员变量的最终值。


#10    ====================================================================================================

（！）使用默认构造函数定义一个对象的实例

class A{

}

错误：A inst();		//定义了一个函数，函数名为inst，返回值为A
正确：A inst;		//定义了一个A的一个实例，叫做inst，使用默认构造函数进行初始化

如果是有参数的构造函数，则有括号是对的

正确: A inst(100,'c');	//定义了一个A的实例，叫做inst，调用的构造函数是 A(int n,char m)


#11    ====================================================================================================

复制构造函数

现在对于类A ，有实例inst1，如果想定义一个新的实例isnt2，且要求值和isnt1一样，那么有下面两种方法实现：

A inst2 = inst1 ; 	//先调用A的默认构造函数，创建一个inst2，然后把inst1赋值给insta2；
A inst2(inst1);		//直接调用编译器提供的复制构造函数，给inst2初始值，这样就避免了“先构造再赋值”
			//这样做的优点见 #7


#12    ====================================================================================================

explict关键字 与 隐式类型转换构造流程(这里不是构造函数，是构造流程)

如果一个类有只接受一个参数的构造函数，那么编译器认为这个类支持隐式类型转换构造流程。

比如：
string a = “123qwer”;   

相当于 

string tmp("123qwer"); 
string a(tmp);

这就出现了中间临时实例tmp。相当于先调用单参数构造函数构造一个中间实例，然后再使用复制构造函数创建想要的实例


（！）如果使用explict修饰单参数的构造函数，则上述动作会在编译时报错


小结：所谓的隐式构造流程是指，当需要某个类的实例时，发现给的参数不满足，但是这个参数可以转型成想要的值，那么
此时先使用参数来 “创建一个中间临时实例”，然后通过复制构造再完成创建。
这样就会造成有一个用来完成类型转换的中间实例的存在，这个实例是临时的，出代码块则被释放。

注意几点：

1）隐式构造仅使用与 “有但参数构造函数的类”
2）explict修饰但参数构造函数时，一旦试图使用隐式类型转换构造流程时，编译器将报错
3）explict只能修饰单参数的构造函数

如果使用了explict那么有：
正确：A inst("123qwer");
错误：A inst = "123qwer";

为了通用起见，建议避免使用隐士构造流程，即不要直接赋值，而是指明了要用什么构造函数来完成构造。


#13    ====================================================================================================


7.5.5  聚合类   P292
15.7
18.1.3
13











































































