#1 ========================================================================================================

空容器：没有任何元素，只表明当前容器内存放什么样的数据
vector<A> v1;
deque<int> d1;

指定容器容量：指定容量，每个元素都使用默认值
vector<A> v1(10);		//10个元素，每个都使用A的默认构造

指定容量和初值：指定容量，给所有元素相同的初值
vector<A> v1(10,A(1));		//使用临时变量A(1)，给容器内的10个元素赋初值
		(需要A有响应的转换/构造函数，比如这里A就要有 A(int) 构造函数)
		
使用两个迭代器之间的值：所有容器都有一个构造函数，那就是接收两个迭代器，使用这两个迭代器中间的值来构造自己
vector<A> v2(v1.begin(),v1.end());		//v2使用v1的所有值来构造自己

使用其他容器构造：所有容器都具备拷贝构造函数
vector<A> v2(v1);			//使用v1来构造v2

使用其他容器赋值：所有容器都具备赋值拷贝函数
vector<A> v2 = v1;			//使用v1给v2赋值

#2 ========================================================================================================

容器的移除元素动作不会调用析构函数，因此如果把对象从容器中移除，请确保使用了 共享指针 或者 手动释放对象。


#3 ========================================================================================================

常用算法：
https://docs.microsoft.com/zh-cn/previous-versions/yah1y2x8(v=vs.120)?redirectedfrom=MSDN


#4 ========================================================================================================

常用的函数对象：
#include <functional>

常用函数对象的adaptor	：  一些对adaptor再包装的函数对象

（！！！）#5 ==============================================================================================

Iterator inserter 迭代器插入器

上面提到了，可以使用 拷贝构造 和 赋值拷贝 来给新的容器赋值/初始化。这个时候被赋值的容器会自动增长到
实参的大小。

比如：v1有10个元素，v2是空容器(或小于10)，这个时候 拷贝构造 和 拷贝赋值 都会让v2变成10个元素。
可见，STL在实现容器模板类的时候考虑到了自动扩容的问题。

但是，如果拷贝和移动相关的泛型算法缺没有考虑到这个问题。还是上面的例子，如果使用copy将 v1 的 2~8号元素
copy给v2 ，则会 coredump，因为v2 是空的(或小于 7的容量)。
（！）这说明，泛型算法的不具备扩容能力。我们在使用copy相关的拷贝/移动算法时，必须保证目的端有足够的容量来接纳
即将到来的数据源。
这个陷阱很危险！！！

根本原因；之所以会有上面的问题，在于copy这些算法的本质是使用了模板参数类的赋值运算符作为底部支撑，因此
		  在解引用赋值的时候会出现解空地址的问题。
		  
那么如果来修补这个问题？？？STL提供了三种 adaptor 修饰 copy类函数的第三个参数(目的容器)。
1) back_inserter(v1)				//在目的容器的尾端增加将要被赋值的元素，比如v1有10个元素，这10个全
									//都拷贝，那么按照之前的说法，v2的容量至少要是10，但是使用这个adapter
									//以后就不需要考虑这个问题了，adapter会自己解决扩容的问题。
									// copy(v1.begin(),v1.end(),back_inserter(v2));		把v1的所有内容追加到v2尾部
									//，会保留v2的原有内容
2) inserter(v1,v1.begin()++)		//在指定位置插入，copy(++v1.begin().--v1.end(),inserter(v2,++v2.begin()))
									//将v1 的 第2 ~ 倒数第2 的元素拷贝到 v2的第2个元素位置，v2的其他元素被排
									//到 v1 拷贝过来的元素后面。
3) front_inserter(v1)				//同上，在首部插入，注：考虑到容器的数据结构，此适配器只能作用于可头部增加的
									//容器————>list 和 deque


#6 ========================================================================================================

iostream iterator的使用

p-112







