#1 ========================================================================================================

空容器：没有任何元素，只表明当前容器内存放什么样的数据
vector<A> v1;
deque<int> d1;

指定容器容量：指定容量，每个元素都使用默认值
vector<A> v1(10);		//10个元素，每个都使用A的默认构造

指定容量和初值：指定容量，给所有元素相同的初值
vector<A> v1(10,A(1));		//使用临时变量A(1)，给容器内的10个元素赋初值
		(需要A有响应的转换/构造函数，比如这里A就要有 A(int) 构造函数)
		
使用两个迭代器之间的值：所有容器都有一个构造函数，那就是接收两个迭代器，使用这两个迭代器中间的值来构造自己
vector<A> v2(v1.begin(),v1.end());		//v2使用v1的所有值来构造自己

使用其他容器构造：所有容器都具备拷贝构造函数
vector<A> v2(v1);			//使用v1来构造v2

使用其他容器赋值：所有容器都具备赋值拷贝函数
vector<A> v2 = v1;			//使用v1给v2赋值

#2 ========================================================================================================

容器的移除元素动作不会调用析构函数，因此如果把对象从容器中移除，请确保使用了 共享指针 或者 手动释放对象。


#3 ========================================================================================================

常用算法：
https://docs.microsoft.com/zh-cn/previous-versions/yah1y2x8(v=vs.120)?redirectedfrom=MSDN


#4 ========================================================================================================

常用的函数对象：
#include <functional>

常用函数对象的adaptor	：  一些对adaptor再包装的函数对象

（！！！）#5 ==============================================================================================

Iterator inserter 迭代器插入器

上面提到了，可以使用 拷贝构造 和 赋值拷贝 来给新的容器赋值/初始化。这个时候被赋值的容器会自动增长到
实参的大小。

比如：v1有10个元素，v2是空容器(或小于10)，这个时候 拷贝构造 和 拷贝赋值 都会让v2变成10个元素。
可见，STL在实现容器模板类的时候考虑到了自动扩容的问题。

但是，如果拷贝和移动相关的泛型算法缺没有考虑到这个问题。还是上面的例子，如果使用copy将 v1 的 2~8号元素
copy给v2 ，则会 coredump，因为v2 是空的(或小于 7的容量)。
（！）这说明，泛型算法的不具备扩容能力。我们在使用copy相关的拷贝/移动算法时，必须保证目的端有足够的容量来接纳
即将到来的数据源。
这个陷阱很危险！！！

根本原因；之所以会有上面的问题，在于copy这些算法的本质是使用了模板参数类的赋值运算符作为底部支撑，因此
		  在解引用赋值的时候会出现解空地址的问题。
		  
那么如果来修补这个问题？？？STL提供了三种 adaptor 修饰 copy类函数的第三个参数(目的容器)。
1) back_inserter(v1)				//在目的容器的尾端增加将要被赋值的元素，比如v1有10个元素，这10个全
									//都拷贝，那么按照之前的说法，v2的容量至少要是10，但是使用这个adapter
									//以后就不需要考虑这个问题了，adapter会自己解决扩容的问题。
									// copy(v1.begin(),v1.end(),back_inserter(v2));		把v1的所有内容追加到v2尾部
									//，会保留v2的原有内容
2) inserter(v1,v1.begin()++)		//在指定位置插入，copy(++v1.begin().--v1.end(),inserter(v2,++v2.begin()))
									//将v1 的 第2 ~ 倒数第2 的元素拷贝到 v2的第2个元素位置，v2的其他元素被排
									//到 v1 拷贝过来的元素后面。
3) front_inserter(v1)				//同上，在首部插入，注：考虑到容器的数据结构，此适配器只能作用于可头部增加的
									//容器————>list 和 deque


#6 ========================================================================================================

mutable的潜台词：

mutable用来解除const的限制，比如我们有一个const实例 const A c_a ; 那么我们无法通过A的成员函数
来修改其成员变量，即便这个成员变量是public的也不行。那么我们如何应对这种场景呢，毕竟实例一旦
被定义成const就表示其中所有成员都是const的，这个时候就可以用mutable修饰想要特殊处理的成员变量。
那么这个时候就可以修改了，即便是cosnt 实例也不影响。

#7 ========================================================================================================

拷贝构造 、拷贝赋值、移动构造、移动赋值 ，这四种 复制类 的动作，都需要在实施 复制 之前对现有对象和
目标对象进行重复检查，即 “不能把自己复制给自己” --->   

		if(this!=&target)	//如果不相同
		{
			//复制值的动作
		}
		return *this;

#8 ========================================================================================================

递增/递减  的前置 和  后置

前置：operator++()	operator--()
后置：operator++(int)  operator--(int)

从众多开源项目的源码中也可窥见，前置用的比较多，因此在编译器的规则中，也将前置动作视为惯用的，这
也便于助记，即前置的重载括号内没有东西，后置重载括号内有int


#9 ========================================================================================================

指向 类成员函数的指针：

指向普通函数的指针很简单，指明返回值和入参列表的类型即可，然后通过通过取值 * 或 括号() 调用即可：
	void func(int){
		....
	}
	typedef void(*pf)(int);
	pfunc pf_1 = func();

	
类比，指向类成员函数的指针需要注意如下几点：
1）需要遵循类的 访问权限控制，即外部指针 只能指向类的 public成员函数，不能指向private，但是如果指针就是
   类的成员，则可以指向private成员函数
2）定义时，需要指明类名，typedef void (A::*pf)(int);
3）使用时，需要 使用 .* 或者 ->* ，或者如果是 静态成员函数被指向了，那么可以直接 A::* 。 即需要绑定到指定
   的类实例才能调用(静态成员函数除外)
4）成员函数地址给指针时要用取地址运算符

例子：

	typedef bool(A::*p_A_fun)(void);			//能够 指向 A中所有 “bool返回值，无入参” 成员函数的指针类型

	p_A_fun p_pub_func;
	p_pub_func = &A::pub_func;				//让p_pub_func指向pub_func成员函数
	
	A a;
	A* pa = new A();
	(a.*p_pub_func)();						//局部实例访问
	(pa->*p_pub_func)();					//堆实例访问
	(A().*p_pub_func)();					//临时实例访问
   
   具体参考 code-cpp 中 “指向成员函数的指针”
   
   
#10 ========================================================================================================

 chapter 5
   
   
   


