###################################################################################################################################


stream buffer场景下，替换缓冲区数据的有两种方法：

1）通过轮询当前播放游标的位置，如果播放游标达到了预定位置(播放前的位置  +  上一次写入的数据量  =  下一次要放入数据的位置)，则
   调用 Lock 锁定下一次放入数据的位置，然后  CopyMemory / memcpy 向 Lock 反馈的可写地址写入数据。
   
2）通过埋设锚点，让directsound播放到指定锚点后，自行通过操作系统向用户反馈( waitmutiobjects 会阻塞等待 ，当播放到指定位置后，操作
   系统会迫使 waitmutiobjects 跳出阻塞，并通过返回值告知用户，当前播放到锚点的位置 )。接着用户根据返回的锚点序号，推导计算出锚点
   距离其实位置的偏移地址，然后 Lock 这个地址，并通过 CopyMemory / memcpy 向 Lock 反馈的可写地址写入数据。
   
		问：为何知道了偏移地址，还要通过Lock再获取一次地址？
		答：因为是环形缓冲区，如果下次写入会导致地址溢出(起始地址+数据量>缓冲区长度)，则会调回到缓冲区首部，因此可能会返回两个
			地址，一个是首次写入地址，另一个是第二次写入的地址。(这里的地址是偏移量点对应的内存地址，我们不能直接写偏移量值，
			偏移量不是内存地址)

			
###################################################################################################################################

			
下面三种情况可能需要使用音频设备的枚举：

1）罗列可用的音频设备(声卡)，以定向选择使用哪个设备进行音频输出
2）为音频设备(声卡)指定 GUID
3）捕获所有音频设备支持的功能和具备的渲染能力

其他情况下，请交给系统来分配设备给用户


 DevicesCollection object  会提供相应的接口来进行音频设备的枚举

###################################################################################################################################


主缓冲(primary buffer)直接面向扬声器，主缓冲存放的数字信号将通过一定的方式转换成模拟信号，通过扬声器输出。

process 1 --- ds-device-obj(directsound) -------------------------------- 		  ---声卡(驱动程序)  ---  promary buffer --- |
					|-- secondary buffer (directsoundbuffer)			|		  |											 |
					|-- secondary buffer (directsoundcapturebuffer)		|		  |--声卡(驱动程序)  ---  promary buffer --- |
					|-- ...												|---------|											 |---  扬声器
																		|		  |--声卡(驱动程序)  ---  promary buffer --- |	
																		|		  |											 |
process 2 --- ds-device-obj(directsound) --------------------------------		  ---声卡(驱动程序)  ---  promary buffer --- |
					|-- 同上

上图可见，每个primary buffer中都可以有 N 个secondary buffer的数据，而这些数据的叠加互不干扰，呈现的效果就是音频的叠加呈现。
具体能有多少secondary buffer同时通过primary buffer输出，这取决于系统的运算能力。

###################################################################################################################################


当 directsound 对象创建时，需要指定声卡设备，当我们指定声卡设备/由系统为我们分配 时，对应的primary buffer也一并创建起来了。


secondary buffer 结构体中有一个参数用来 描述当前二级缓冲中存放数据的 音频参数和格式。
primary buffer 结构体中同样也有一个参数用来描述主缓冲中存放数据的音频参数和格式。
（！）不论 secondary buffer 的格式是什么样的， 最终进入 primary buffer中，都将遵从主缓冲的 参数和 格式约束。


###################################################################################################################################


音频数据可以存放在硬件缓冲区 和 软件缓冲区，硬件缓冲区是指存储在声卡上，同时渲染也由声卡负责。软件缓冲区存储在操作系统中，由CPU渲染

为了提高音频质量，可以将数据交由声卡处理(需要调用声卡的库将数据转移至声卡中，再使用响应的渲染API进行处理和输出)。
	reference ：https://docs.microsoft.com/en-us/previous-versions/ms804976%28v%3dmsdn.10%29
	

###################################################################################################################################


（！）主缓冲区由系统维护，它会自动mix所有secondary buffer的数据，且对这些数据“一视同仁”，如果我们想要特殊对待某些secondary buffer，
那么我们需要自己管理primary buffer，一旦我们接手，那么原先的策略将被覆盖，因此需要明确知道混音的工作机制才可以自己操作primary buffer。


###################################################################################################################################


secondary buffer 对象由 directsound 类创建和管理，如果directsound实例被释放了，那么对应的secondary buffer也将被析构。因此，我们不用
关心secondary buffer的释放，只需要正确释放directsound实例即可。


###################################################################################################################################


上面提到了，可以把音频数据存在声卡上。因此我们需要先让Directsound告诉声卡为我们分配secondary buffer(音频数据落地必须在secondary buffer。
中，不管是在系统内存里，还是在声卡内存里)。

换句话说，其实是directsound控制着 secondary buffer 到底是放在操作系统内，还是放在声卡内。

我们可以通过 secondary buffer 对象提供的接口来做如下查询：
1）当前secondary buffer存在于操作系统中，还是存在于声卡内存中（ LocateInHardware为true，则表示在声卡中）
2）当前secondary buffer是否开启了存入声卡的限制
3）Setting BufferDescription.StaticBuffer lets DirectSound know that the buffer should be created in on-board hardware memory if possible. 

对于一些短小的声音，可以把他们存入flash这种板级的高速内存中。以提高访问效率。
（！）因此，secondary buffer的存在位置可以有三个： 1）操作系统中(内存/交换区)  2）声卡内存中  3）板级高速缓冲区(flash/寄存器/缓存/...)


	由此可见，secondary buffer是一个操作系统级的结构，DirectSound的访问权限也相当大，从硬件到操作系统无一不能安插自己的“手下”


###################################################################################################################################


secondary buffer 对于存放在其中的数据拥有绝对的控制权，同时，其也对用户提供了一套配置控制的参数。

secondary buffer 有三个存储位置，因此我们可以灵活调整各个存储位置的能力集配置，比如把所有存储在声卡上的 secondary buffer 都设置成
可以控制音量，而其他的都设置成不可以控制音量，这样就可以让音量控制完全有声卡来实现。

如果某个 secondary buffer 不支持某个控制功能，但认为地强硬控制，则会导致异常发生。


###################################################################################################################################


https://docs.microsoft.com/en-us/previous-versions/ms804968%28v%3dmsdn.10%29

3-D Algorithms for Buffers

https://docs.microsoft.com/en-us/previous-versions/ms804975%28v%3dmsdn.10%29

TerminateByTime

https://docs.microsoft.com/zh-cn/quantum/overview/what-is-quantum-computing?view=qsharp-preview



